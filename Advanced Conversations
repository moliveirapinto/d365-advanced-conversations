<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Conversations</title>
    <!-- D3.js for data visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Fluent UI System Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fluentui/svg-icons@1.1.239/fonts/FluentSystemIcons-Regular.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            padding: 0;
            color: #0a0a0a;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            right: -10%;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.08) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            animation: float 20s ease-in-out infinite;
        }

        body::after {
            content: '';
            position: fixed;
            bottom: -30%;
            left: -5%;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(236, 72, 153, 0.06) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            animation: float 25s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(30px, -30px) rotate(120deg); }
            66% { transform: translate(-20px, 20px) rotate(240deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            padding: 0 48px 48px 48px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 24px 24px 24px;
            }
        }

        /* Header Section */
        .header {
            background: #ffffff;
            padding: 32px 40px;
            margin: 0 0 32px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 32px;
            position: relative;
            z-index: 1;
            border-bottom: 2px solid #f0f0f0;
        }

        .welcome-section {
            flex: 1;
            min-width: 0;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .welcome-section .header-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 2px solid #e2e8f0;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .welcome-section .header-icon svg {
            width: 24px;
            height: 24px;
            stroke: #475569;
        }

        .welcome-section .header-text {
            flex: 1;
        }

        .welcome-section h1 {
            font-size: 22px;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 2px;
            letter-spacing: -0.3px;
        }

        .welcome-section p {
            color: #64748b;
            font-size: 13px;
            font-weight: 500;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .refresh-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            background: #ffffff;
            color: #374151;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .refresh-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .refresh-btn:active {
            transform: scale(0.98);
        }

        .download-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: #0f172a;
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .download-btn:hover:not(:disabled) {
            background: #1e293b;
        }

        .download-btn:active:not(:disabled) {
            transform: scale(0.98);
        }

        .download-btn:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
        }

        .download-btn .badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
        }

        /* Checkbox styles */
        .checkbox-cell {
            width: 40px;
            text-align: center;
        }

        .conv-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #6366f1;
        }

        .select-all-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #6366f1;
        }

        /* Download Modal */
        .download-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .download-modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .download-modal {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
        }

        .download-modal-overlay.open .download-modal {
            transform: scale(1);
        }

        .download-modal-header {
            padding: 24px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: white;
        }

        .download-modal-header h2 {
            font-size: 20px;
            font-weight: 800;
            margin-bottom: 4px;
        }

        .download-modal-header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .download-modal-body {
            padding: 24px;
            max-height: 400px;
            overflow-y: auto;
        }

        .download-progress {
            margin-bottom: 20px;
        }

        .progress-bar-container {
            background: #e5e5e5;
            border-radius: 10px;
            height: 12px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .progress-text {
            font-size: 13px;
            color: #737373;
            text-align: center;
        }

        .download-log {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 10px;
            padding: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .download-log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .download-log-entry:last-child {
            border-bottom: none;
        }

        .download-log-entry.success {
            color: #16a34a;
        }

        .download-log-entry.error {
            color: #dc2626;
        }

        .download-log-entry.info {
            color: #475569;
        }
        
        /* Format Selection Styles */
        .format-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .format-option {
            cursor: pointer;
        }
        
        .format-option input[type="radio"] {
            display: none;
        }
        
        .format-option-content {
            display: flex;
            gap: 16px;
            padding: 16px;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            transition: all 0.2s ease;
            background: #fafafa;
        }
        
        .format-option input[type="radio"]:checked + .format-option-content {
            border-color: #0f172a;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.05) 0%, rgba(30, 41, 59, 0.05) 100%);
        }
        
        .format-option:hover .format-option-content {
            border-color: #94a3b8;
            background: #f5f5f5;
        }
        
        .format-option input[type="radio"]:checked + .format-option-content:hover {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.08) 0%, rgba(30, 41, 59, 0.08) 100%);
        }
        
        .format-option-icon {
            font-size: 28px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .format-option-details {
            flex: 1;
        }
        
        .format-option-title {
            font-weight: 700;
            font-size: 14px;
            color: #0a0a0a;
            margin-bottom: 4px;
        }
        
        .format-option-desc {
            font-size: 12px;
            color: #737373;
            line-height: 1.4;
        }

        .download-modal-footer {
            padding: 16px 24px;
            border-top: 1px solid #e5e5e5;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn-primary {
            background: #0f172a;
            color: white;
            border: none;
        }

        .modal-btn-primary:hover:not(:disabled) {
            background: #1e293b;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.3);
        }

        .modal-btn-primary:disabled {
            background: #a3a3a3;
            cursor: not-allowed;
        }

        /* Assign Agent Modal Specific Styles */
        .agent-search-box {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            background: #fafafa;
            margin-bottom: 16px;
            transition: all 0.2s ease;
        }

        .agent-search-box:focus-within {
            border-color: #16a34a;
            background: white;
            box-shadow: 0 0 0 3px rgba(22, 163, 74, 0.1);
        }

        .agent-search-box svg {
            color: #737373;
            flex-shrink: 0;
        }

        .agent-search-box input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 14px;
            outline: none;
            color: #0a0a0a;
        }

        .agent-search-box input::placeholder {
            color: #a3a3a3;
        }

        /* Professional Assign Agent Modal Styles */
        .assign-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .assign-modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .assign-modal {
            background: white;
            border-radius: 20px;
            width: 520px;
            max-width: 95vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.25), 0 10px 30px rgba(0, 0, 0, 0.15);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            overflow: hidden;
        }

        .assign-modal-overlay.open .assign-modal {
            transform: scale(1) translateY(0);
        }

        .assign-modal-header {
            background: linear-gradient(135deg, #059669 0%, #047857 50%, #065f46 100%);
            padding: 28px 32px 24px;
            position: relative;
            overflow: hidden;
        }

        .assign-modal-header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -20%;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
            border-radius: 50%;
        }

        .assign-modal-header::after {
            content: '';
            position: absolute;
            bottom: -30%;
            left: -10%;
            width: 150px;
            height: 150px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 50%;
        }

        .assign-modal-header-content {
            position: relative;
            z-index: 1;
        }

        .assign-modal-icon {
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
        }

        .assign-modal-icon svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .assign-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: white;
            margin: 0 0 6px 0;
            letter-spacing: -0.5px;
        }

        .assign-modal-subtitle {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.85);
            margin: 0;
            font-weight: 400;
        }

        .assign-modal-body {
            padding: 24px 28px;
            flex: 1;
            overflow-y: auto;
        }

        /* Search Box */
        .agent-search-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .agent-search-wrapper svg {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            color: #9ca3af;
            pointer-events: none;
            transition: color 0.2s;
        }

        .agent-search-input {
            width: 100%;
            padding: 14px 16px 14px 48px;
            border: 2px solid #e5e7eb;
            border-radius: 14px;
            font-size: 15px;
            background: #f9fafb;
            transition: all 0.2s ease;
            outline: none;
            color: #1f2937;
        }

        .agent-search-input:focus {
            border-color: #10b981;
            background: white;
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.1);
        }

        .agent-search-input:focus + svg,
        .agent-search-wrapper:focus-within svg {
            color: #10b981;
        }

        .agent-search-input::placeholder {
            color: #9ca3af;
        }

        /* Agent Grid */
        .agent-grid {
            display: grid;
            gap: 10px;
            max-height: 340px;
            overflow-y: auto;
            padding: 4px;
            margin: 0 -4px;
        }

        .agent-grid::-webkit-scrollbar {
            width: 6px;
        }

        .agent-grid::-webkit-scrollbar-track {
            background: transparent;
        }

        .agent-grid::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        .agent-grid::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* Agent Card */
        .agent-card {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            background: #f9fafb;
            border: 2px solid transparent;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .agent-card:hover {
            background: #ecfdf5;
            border-color: #a7f3d0;
            transform: translateY(-1px);
        }

        .agent-card.selected {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border-color: #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.15);
        }

        .agent-card.selected:hover {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        }

        .agent-card-avatar {
            width: 48px;
            height: 48px;
            border-radius: 14px;
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .agent-card-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .agent-card-avatar .initials {
            font-weight: 700;
            font-size: 16px;
            color: white;
            text-transform: uppercase;
        }

        .agent-card-info {
            flex: 1;
            min-width: 0;
        }

        .agent-card-name {
            font-weight: 600;
            font-size: 15px;
            color: #1f2937;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-card.selected .agent-card-name {
            color: #047857;
        }

        .agent-card-status {
            font-size: 13px;
            color: #059669;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .agent-card-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2); }
            50% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.1); }
        }

        .agent-card-check {
            width: 24px;
            height: 24px;
            border: 2px solid #d1d5db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .agent-card.selected .agent-card-check {
            background: #10b981;
            border-color: #10b981;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .agent-card-check svg {
            width: 14px;
            height: 14px;
            color: white;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s ease;
        }

        .agent-card.selected .agent-card-check svg {
            opacity: 1;
            transform: scale(1);
        }

        /* Selected Agent Banner */
        .selected-agent-banner {
            margin-top: 20px;
            padding: 16px 20px;
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 14px;
            display: none;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .selected-agent-banner.visible {
            display: block;
        }

        .selected-agent-banner-label {
            font-size: 11px;
            font-weight: 700;
            color: #059669;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .selected-agent-banner-label svg {
            width: 14px;
            height: 14px;
        }

        .selected-agent-banner-content {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .selected-agent-banner-content .agent-card-avatar {
            width: 44px;
            height: 44px;
            border-radius: 12px;
        }

        .selected-agent-banner-content .agent-card-name {
            font-size: 16px;
            color: #047857;
        }

        /* Loading State */
        .agent-grid-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .agent-grid-loading .spinner-ring {
            width: 48px;
            height: 48px;
            border: 4px solid #e5e7eb;
            border-top-color: #10b981;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .agent-grid-loading span {
            font-size: 14px;
            color: #6b7280;
        }

        /* Empty State */
        .agent-grid-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .agent-grid-empty .empty-icon {
            width: 72px;
            height: 72px;
            background: #f3f4f6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
        }

        .agent-grid-empty .empty-icon svg {
            width: 36px;
            height: 36px;
            color: #9ca3af;
        }

        .agent-grid-empty .empty-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
        }

        .agent-grid-empty .empty-desc {
            font-size: 14px;
            color: #6b7280;
        }

        /* Progress Section */
        .assign-progress-section {
            display: none;
        }

        .assign-progress-section.visible {
            display: block;
        }

        .assign-progress-bar-wrapper {
            background: #e5e7eb;
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .assign-progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #059669 100%);
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .assign-progress-text {
            font-size: 14px;
            color: #374151;
            text-align: center;
            margin-bottom: 16px;
        }

        .assign-log {
            max-height: 200px;
            overflow-y: auto;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
        }

        .assign-log-entry {
            font-size: 13px;
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .assign-log-entry:last-child {
            margin-bottom: 0;
        }

        .assign-log-entry.success {
            background: #ecfdf5;
            color: #047857;
        }

        .assign-log-entry.error {
            background: #fef2f2;
            color: #b91c1c;
        }

        .assign-log-entry.info {
            background: #eff6ff;
            color: #1d4ed8;
        }

        /* Footer */
        .assign-modal-footer {
            padding: 20px 28px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .assign-btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .assign-btn-secondary {
            background: white;
            color: #4b5563;
            border: 2px solid #e5e7eb;
        }

        .assign-btn-secondary:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .assign-btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 14px rgba(16, 185, 129, 0.3);
        }

        .assign-btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.35);
        }

        .assign-btn-primary:disabled {
            background: #d1d5db;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        .assign-btn svg {
            width: 18px;
            height: 18px;
        }

        .agent-list {
            max-height: 320px;
            overflow-y: auto;
            border: 1px solid #e5e5e5;
            border-radius: 10px;
            background: white;
        }

        .agent-list-loading {
            padding: 40px;
            text-align: center;
            color: #737373;
        }

        .agent-list-loading .spinner {
            width: 32px;
            height: 32px;
            margin: 0 auto 12px;
        }

        .agent-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .agent-list-item:last-child {
            border-bottom: none;
        }

        .agent-list-item:hover {
            background: #f0fdf4;
        }

        .agent-list-item.selected {
            background: linear-gradient(135deg, rgba(22, 163, 74, 0.1) 0%, rgba(21, 128, 61, 0.08) 100%);
            border-left: 3px solid #16a34a;
        }

        .agent-list-item.selected:hover {
            background: linear-gradient(135deg, rgba(22, 163, 74, 0.15) 0%, rgba(21, 128, 61, 0.12) 100%);
        }

        .agent-item-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #e5e5e5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            flex-shrink: 0;
        }

        .agent-item-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .agent-item-avatar .avatar-initials {
            font-weight: 700;
            font-size: 14px;
            color: white;
        }

        .agent-item-details {
            flex: 1;
            min-width: 0;
        }

        .agent-item-name {
            font-weight: 600;
            font-size: 14px;
            color: #0a0a0a;
            margin-bottom: 2px;
        }

        .agent-item-status {
            font-size: 12px;
            color: #16a34a;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .agent-item-status::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #16a34a;
            display: inline-block;
        }

        .agent-item-check {
            width: 20px;
            height: 20px;
            border: 2px solid #e5e5e5;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .agent-list-item.selected .agent-item-check {
            background: #16a34a;
            border-color: #16a34a;
        }

        .agent-item-check svg {
            width: 12px;
            height: 12px;
            color: white;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .agent-list-item.selected .agent-item-check svg {
            opacity: 1;
        }

        .selected-agent-display {
            margin-top: 16px;
            padding: 16px;
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            border: 2px solid #86efac;
            border-radius: 10px;
        }

        .selected-agent-label {
            font-size: 12px;
            font-weight: 600;
            color: #15803d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .selected-agent-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .selected-agent-info .agent-item-avatar {
            width: 36px;
            height: 36px;
        }

        .selected-agent-info .agent-item-name {
            font-size: 15px;
            color: #15803d;
        }

        .agent-list-empty {
            padding: 40px;
            text-align: center;
            color: #737373;
        }

        .agent-list-empty svg {
            width: 48px;
            height: 48px;
            color: #d1d5db;
            margin-bottom: 12px;
        }

        .modal-btn-secondary {
            background: white;
            color: #525252;
            border: 2px solid #e5e5e5;
        }

        .modal-btn-secondary:hover {
            background: #f5f5f5;
            border-color: #d1d5db;
        }

        .modal-btn-secondary {
            background: #f5f5f5;
            color: #525252;
            border: 1px solid #e5e5e5;
        }

        .modal-btn-secondary:hover {
            background: #e5e5e5;
        }

        /* Selection actions in table header */
        .selection-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .selection-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #525252;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .selection-btn:hover {
            background: #e5e5e5;
            color: #0a0a0a;
        }

        .selection-btn.clear-btn:hover {
            background: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .selection-btn.download-action-btn {
            background: #0f172a;
            border-color: #0f172a;
            color: white;
        }

        .selection-btn.download-action-btn:hover:not(:disabled) {
            background: #1e293b;
            border-color: #1e293b;
        }

        .selection-btn.download-action-btn:disabled {
            background: #cbd5e1;
            border-color: #cbd5e1;
            color: #94a3b8;
            cursor: not-allowed;
        }

        .selection-btn.close-conversations-btn {
            background: #fef2f2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .selection-btn.close-conversations-btn:hover:not(:disabled) {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #b91c1c;
        }

        .selection-btn.close-conversations-btn:disabled {
            background: #f5f5f5;
            border-color: #e5e5e5;
            color: #a3a3a3;
            cursor: not-allowed;
        }

        .selection-btn.assign-agent-btn {
            background: #f0fdf4;
            border-color: #bbf7d0;
            color: #16a34a;
        }

        .selection-btn.assign-agent-btn:hover:not(:disabled) {
            background: #dcfce7;
            border-color: #86efac;
            color: #15803d;
        }

        .selection-btn.assign-agent-btn:disabled {
            background: #f5f5f5;
            border-color: #e5e5e5;
            color: #a3a3a3;
            cursor: not-allowed;
        }

        .selection-btn.reset-columns-btn:hover {
            background: #eff6ff;
            border-color: #93c5fd;
            color: #2563eb;
        }

        .selection-btn.columns-btn:hover {
            background: #f0fdf4;
            border-color: #86efac;
            color: #16a34a;
        }

        /* Column selector dropdown */
        .column-selector {
            position: relative;
        }

        .column-selector-dropdown {
            position: fixed;
            right: auto;
            margin-top: 8px;
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            min-width: 320px;
            max-height: 70vh;
            z-index: 9999;
            display: none;
            overflow: hidden;
            flex-direction: column;
        }

        .column-selector-dropdown.open {
            display: flex;
        }

        .column-selector-header {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e5e5;
            font-weight: 600;
            font-size: 13px;
            color: #525252;
            background: #fafafa;
        }
        
        .column-selector-search {
            padding: 8px 12px;
            border-bottom: 1px solid #e5e5e5;
        }
        
        .column-selector-search input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .column-selector-search input:focus {
            border-color: #6366f1;
        }
        
        .column-selector-search input::placeholder {
            color: #9ca3af;
        }

        .column-selector-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        
        .column-selector-group {
            margin-bottom: 8px;
        }
        
        .column-selector-group-title {
            padding: 8px 16px;
            font-size: 11px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #f0f0f0;
            border-top: 1px solid #e5e5e5;
            border-bottom: 1px solid #e5e5e5;
            position: sticky;
            top: 0;
            z-index: 1;
            white-space: nowrap;
            line-height: 1.4;
        }
        
        .column-selector-empty {
            padding: 16px;
            text-align: center;
            color: #9ca3af;
            font-size: 13px;
        }

        .column-selector-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.15s;
            font-size: 13px;
            color: #525252;
        }

        .column-selector-item:hover {
            background: #f5f5f5;
        }

        .column-selector-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .column-selector-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #6366f1;
            cursor: pointer;
        }

        .column-selector-item.disabled input[type="checkbox"] {
            cursor: not-allowed;
        }

        .column-selector-footer {
            padding: 10px 16px;
            border-top: 1px solid #e5e5e5;
            background: #fafafa;
        }

        .column-selector-footer button {
            width: 100%;
            padding: 8px 12px;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            color: #525252;
            cursor: pointer;
            transition: all 0.2s;
        }

        .column-selector-footer button:hover {
            background: #e5e5e5;
            color: #0a0a0a;
        }

        .conversations-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        @media (max-width: 1200px) {
            .stats-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            padding: 20px;
            border-radius: 16px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--card-color, #6366f1);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform 0.3s ease;
        }

        .stat-card:hover::before {
            transform: scaleX(1);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            border-color: #d4d4d4;
        }

        .stat-card.active {
            border-color: var(--card-color, #6366f1);
            background: linear-gradient(to bottom, rgba(var(--card-rgb), 0.04), #ffffff);
        }

        .stat-card.active::before {
            transform: scaleX(1);
        }

        .stat-card-content {
            display: flex;
            align-items: flex-start;
            gap: 14px;
        }

        .stat-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            flex-shrink: 0;
        }

        .stat-icon svg {
            width: 20px;
            height: 20px;
            color: var(--card-color);
        }

        .stat-info {
            flex: 1;
            min-width: 0;
        }

        .stat-card .stat-value {
            font-size: 32px;
            font-weight: 800;
            color: #0a0a0a;
            letter-spacing: -1px;
            line-height: 1.1;
        }

        .stat-card .stat-label {
            font-size: 12px;
            color: #737373;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-top: 4px;
        }

        .stat-trend {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 8px;
            padding: 3px 8px;
            border-radius: 20px;
            background: #f5f5f5;
            color: #525252;
        }

        .stat-trend.up {
            background: #dcfce7;
            color: #16a34a;
        }

        .stat-trend.down {
            background: #fee2e2;
            color: #dc2626;
        }

        .stat-trend svg {
            width: 12px;
            height: 12px;
        }

        /* Filters Section */
        .filters-section {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            padding: 24px;
            border-radius: 20px;
            margin-bottom: 24px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 150px;
            flex: 0 0 auto;
        }

        .filter-group label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #737373;
        }

        .filter-group select,
        .filter-group input {
            padding: 12px 16px;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            background: #fafafa;
            color: #0a0a0a;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #6366f1;
            background: white;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .filter-tabs {
            display: flex;
            gap: 8px;
            background: #f5f5f5;a
            padding: 4px;
            border-radius: 12px;
            flex-shrink: 0;
        }

        .filter-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 700;
            color: #737373;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .filter-tab.active {
            background: #ffffff;
            color: #6366f1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .filter-tab:hover:not(.active) {
            color: #0a0a0a;
        }

        .clear-filters-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: none;
            background: transparent;
            color: #dc2626;
            font-size: 13px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: auto;
            white-space: nowrap;
        }

        .clear-filters-btn:hover {
            background: #fef2f2;
            color: #b91c1c;
        }

        .clear-filters-btn svg {
            flex-shrink: 0;
        }

        .search-box {
            flex: 1;
            min-width: 180px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 12px 16px 12px 44px;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            background: #fafafa;
        }

        .search-box input:focus {
            outline: none;
            border-color: #6366f1;
            background: white;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .search-box svg {
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: #737373;
            width: 20px;
            height: 20px;
        }

        /* Analytics Dashboard */
        .dashboard-section {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 24px;
            transition: all 0.3s ease;
        }

        .dashboard-section.collapsed {
            padding: 16px 24px;
        }

        .dashboard-section.collapsed .dashboard-charts {
            display: none;
        }

        .dashboard-section.collapsed .dashboard-header {
            margin-bottom: 0;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .dashboard-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .dashboard-header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dashboard-toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #525252;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dashboard-toggle-btn:hover {
            background: #ebebeb;
            border-color: #d4d4d4;
            color: #0a0a0a;
        }

        .dashboard-toggle-btn svg {
            transition: transform 0.3s ease;
        }

        .dashboard-section.collapsed .dashboard-toggle-btn svg {
            transform: rotate(-90deg);
        }

        .dashboard-title {
            font-size: 18px;
            font-weight: 700;
            color: #0a0a0a;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dashboard-title svg {
            color: #0a0a0a;
        }

        .dashboard-subtitle {
            font-size: 13px;
            color: #737373;
        }

        .dashboard-charts {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .dashboard-charts {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .dashboard-charts {
                grid-template-columns: 1fr;
            }
        }

        .chart-card {
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .chart-card:hover {
            border-color: #d4d4d4;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-shrink: 0;
        }

        .chart-title {
            font-size: 14px;
            font-weight: 700;
            color: #0a0a0a;
            display: flex;
            align-items: center;
        }

        .chart-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 180px;
            flex-direction: column;
            flex: 1;
        }

        .chart-container .bar-chart-container {
            width: 100%;
        }

        .chart-container .stacked-bar-chart {
            width: 100%;
        }

        .chart-container svg {
            overflow: visible;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 16px;
            justify-content: center;
        }

        .chart-legend:empty {
            margin-top: 0;
            display: none;
        }

        /* Side legend layout for donut chart */
        .chart-with-side-legend {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 8px 0;
            flex: 1;
            justify-content: center;
        }

        .chart-with-side-legend .chart-container {
            flex-shrink: 0;
        }

        .chart-side-legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            min-width: 0;
            max-height: 180px;
            overflow-y: auto;
        }

        .chart-side-legend:empty {
            display: none;
        }

        .chart-side-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #525252;
            padding: 6px 10px;
            background: #fafafa;
            border-radius: 8px;
            transition: background 0.2s ease;
        }

        .chart-side-legend .legend-item:hover {
            background: #f0f0f0;
        }

        .chart-side-legend .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .chart-side-legend .legend-label {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
        }

        .chart-side-legend .legend-value {
            font-weight: 700;
            color: #0a0a0a;
            flex-shrink: 0;
        }

        .chart-side-legend .legend-percent {
            font-size: 10px;
            color: #a3a3a3;
            flex-shrink: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #525252;
            padding: 4px 8px;
            background: #ffffff;
            border-radius: 8px;
            border: 1px solid #e5e5e5;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            border-color: #a5a5a5;
            background: #fafafa;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .legend-label {
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .legend-percent {
            font-weight: 600;
            color: #0a0a0a;
        }

        .chart-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 180px;
            color: #a3a3a3;
            font-size: 13px;
        }

        .chart-empty svg {
            width: 40px;
            height: 40px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        /* Donut chart center text */
        .chart-center-text {
            font-size: 24px;
            font-weight: 800;
            fill: #0a0a0a;
        }

        .chart-center-label {
            font-size: 11px;
            fill: #737373;
        }

        /* Horizontal Bar Chart styles */
        .bar-chart-container {
            width: 100%;
            padding: 0 8px;
        }

        .bar-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }

        .bar-label {
            font-size: 11px;
            color: #525252;
            width: 80px;
            flex-shrink: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: right;
        }

        .bar-track {
            flex: 1;
            height: 24px;
            background: #f5f5f5;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
            min-width: 40px;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .bar-value {
            font-size: 10px;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .bar-count {
            font-size: 11px;
            font-weight: 600;
            color: #0a0a0a;
            width: 45px;
            flex-shrink: 0;
            text-align: right;
        }

        /* Stacked Bar Chart styles */
        .stacked-bar-chart {
            width: 100%;
            padding: 10px 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
        }

        .stacked-bar-track {
            width: 100%;
            height: 32px;
            background: #f5f5f5;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
        }

        .stacked-bar-segment {
            height: 100%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            cursor: pointer;
        }

        .stacked-bar-segment:hover {
            filter: brightness(1.1);
        }

        .stacked-bar-segment:first-child {
            border-radius: 8px 0 0 8px;
        }

        .stacked-bar-segment:last-child {
            border-radius: 0 8px 8px 0;
        }

        .stacked-bar-segment:only-child {
            border-radius: 8px;
        }

        .stacked-bar-labels {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 14px;
            justify-content: center;
        }

        .stacked-bar-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #525252;
        }

        .stacked-bar-dot {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .stacked-bar-name {
            font-weight: 500;
        }

        .stacked-bar-value {
            font-weight: 700;
            color: #0a0a0a;
        }

        .stacked-bar-percent {
            font-size: 10px;
            font-weight: 600;
            color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 2px;
        }

        /* Conversations Table */
        .conversations-card {
            background: #ffffff;
            border: 2px solid #e5e5e5;
            border-radius: 20px;
            overflow: hidden;
        }

        .conversations-header {
            padding: 24px;
            border-bottom: 2px solid #f5f5f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .conversations-title {
            font-size: 20px;
            font-weight: 800;
            color: #0a0a0a;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .conversations-count {
            background: #6366f1;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
        }

        .table-container {
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #fafafa;
        }

        th {
            padding: 16px 20px;
            text-align: left;
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #737373;
            border-bottom: 2px solid #f5f5f5;
            white-space: nowrap;
        }

        th.sortable {
            cursor: pointer;
            user-select: none;
        }

        th.sortable:hover {
            color: #6366f1;
        }

        /* Draggable columns */
        th.draggable {
            cursor: grab;
            user-select: none;
            position: relative;
            transition: background 0.2s, transform 0.2s;
        }

        th.draggable::before {
            content: '';
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #d4d4d4;
            letter-spacing: -2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        th.draggable:hover::before {
            opacity: 1;
        }

        th.draggable:hover {
            background: #f5f5f5;
            padding-left: 20px;
        }

        th.draggable.dragging {
            opacity: 0.5;
            background: #e0e7ff;
            cursor: grabbing;
        }

        th.draggable.drag-over {
            background: #e0e7ff;
            box-shadow: inset 0 0 0 2px #6366f1;
        }

        th.draggable.drag-over-left {
            box-shadow: inset 3px 0 0 0 #6366f1;
        }

        th.draggable.drag-over-right {
            box-shadow: inset -3px 0 0 0 #6366f1;
        }

        th .sort-icon {
            margin-left: 6px;
            opacity: 0.5;
        }

        th.sorted .sort-icon {
            opacity: 1;
            color: #6366f1;
        }

        td {
            padding: 16px 20px;
            font-size: 14px;
            color: #0a0a0a;
            border-bottom: 1px solid #f5f5f5;
            vertical-align: middle;
        }

        tr {
            transition: all 0.2s;
            cursor: pointer;
        }

        tr:hover {
            background: #fafafa;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .conversation-id {
            font-weight: 700;
            color: #6366f1;
            font-size: 13px;
        }

        .customer-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .customer-name {
            font-weight: 700;
            color: #0a0a0a;
        }

        .customer-channel {
            font-size: 12px;
            color: #737373;
        }

        .agent-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .agent-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 12px;
            flex-shrink: 0;
            overflow: hidden;
        }

        .agent-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .agent-name {
            font-weight: 600;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-badge.status-active {
            background: #eff6ff;
            color: #2563eb;
            border: 2px solid #dbeafe;
        }

        .status-badge.status-open {
            background: #fef3c7;
            color: #d97706;
            border: 2px solid #fde68a;
        }

        .status-badge.status-waiting {
            background: #fef3c7;
            color: #d97706;
            border: 2px solid #fde68a;
        }

        .status-badge.status-wrapup {
            background: #f3e8ff;
            color: #9333ea;
            border: 2px solid #e9d5ff;
        }

        .status-badge.status-closed {
            background: #f0fdf4;
            color: #16a34a;
            border: 2px solid #bbf7d0;
        }

        .channel-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            background: #f5f5f5;
            color: #525252;
        }

        .channel-badge svg {
            width: 14px;
            height: 14px;
        }

        .duration-cell {
            font-weight: 600;
            color: #525252;
        }

        .date-cell {
            font-size: 13px;
            color: #737373;
        }

        .date-cell .time {
            font-weight: 600;
            color: #0a0a0a;
        }

        .text-muted {
            color: #a3a3a3;
            font-style: italic;
        }

        /* Pagination */
        .pagination {
            padding: 20px 24px;
            border-top: 2px solid #f5f5f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pagination-info {
            font-size: 14px;
            color: #737373;
            font-weight: 600;
        }

        .pagination-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 16px;
            padding-right: 16px;
            border-right: 2px solid #e5e5e5;
        }

        .page-size-selector label {
            font-size: 13px;
            color: #737373;
            font-weight: 600;
        }

        .page-size-selector select {
            padding: 6px 12px;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #525252;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .page-size-selector select:hover {
            border-color: #6366f1;
        }

        .page-size-selector select:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .page-btn {
            padding: 8px 16px;
            border: 2px solid #e5e5e5;
            background: #ffffff;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .page-btn:hover:not(:disabled) {
            border-color: #6366f1;
            color: #6366f1;
        }

        .page-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .page-btn.active {
            background: #6366f1;
            border-color: #6366f1;
            color: white;
        }

        /* Loading & Empty States */
        .loading {
            text-align: center;
            padding: 60px;
            color: #737373;
        }

        .spinner {
            border: 3px solid #f5f5f5;
            border-top: 3px solid #6366f1;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #737373;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state p {
            font-weight: 600;
            color: #737373;
            font-size: 16px;
        }

        /* Queue Badge */
        .queue-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            background: #f0f9ff;
            color: #0369a1;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Workstream Badge */
        .workstream-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(99, 102, 241, 0.1);
            color: #6366f1;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Sentiment Badge Styles */
        .sentiment-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            border: 1px solid transparent;
        }

        .sentiment-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .sentiment-na {
            background: #f5f5f5;
            color: #737373;
            border-color: #e5e5e5;
        }

        .sentiment-very-negative {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            color: #991b1b;
            border-color: #fecaca;
        }

        .sentiment-negative {
            background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
            color: #9a3412;
            border-color: #fdba74;
        }

        .sentiment-slightly-negative {
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            color: #92400e;
            border-color: #fde68a;
        }

        .sentiment-neutral {
            background: #f5f5f5;
            color: #525252;
            border-color: #e5e5e5;
        }

        .sentiment-slightly-positive {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            color: #166534;
            border-color: #bbf7d0;
        }

        .sentiment-positive {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            color: #065f46;
            border-color: #6ee7b7;
        }

        .sentiment-very-positive {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #064e3b;
            border-color: #34d399;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .filters-section {
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .filter-group {
                min-width: 140px;
                flex: 1 1 140px;
            }
            
            .filter-group.searchable-dropdown-group {
                flex: 1 1 180px;
            }
            
            .search-box {
                flex: 1 1 200px;
                min-width: 180px;
            }
            
            .filter-tabs {
                flex: 0 0 auto;
            }
        }

        /* Enhanced Responsive Styles */
        @media (max-width: 992px) {
            .header {
                flex-direction: column;
                padding: 20px;
                gap: 16px;
            }
            
            .welcome-section {
                width: 100%;
                justify-content: flex-start;
            }
            
            .header-actions {
                width: 100%;
                justify-content: flex-start;
                flex-wrap: wrap;
            }
            
            .selection-actions {
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .selection-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .column-selector-dropdown {
                min-width: 250px;
                max-height: 350px;
            }
            
            .conversations-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .filters-section {
                padding: 16px;
                gap: 12px;
            }
            
            .filter-tabs {
                width: 100%;
                order: -1;
                justify-content: center;
            }
            
            .filter-group {
                flex: 1 1 calc(50% - 6px);
                min-width: 0;
            }
            
            .filter-group.searchable-dropdown-group {
                flex: 1 1 calc(50% - 6px);
            }
            
            .filter-group.date-picker-group {
                flex: 1 1 calc(50% - 6px);
            }
            
            .search-box {
                flex: 1 1 100%;
                order: 10;
            }
            
            .clear-filters-btn {
                order: 11;
                margin-left: 0;
                justify-content: center;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 12px 12px 12px;
            }
            
            .header {
                padding: 16px;
            }
            
            .welcome-section h1 {
                font-size: 18px;
            }
            
            .welcome-section p {
                font-size: 12px;
            }
            
            .welcome-section .header-icon {
                width: 40px;
                height: 40px;
            }
            
            .refresh-btn,
            .download-btn {
                padding: 8px 14px;
                font-size: 12px;
            }
            
            .stat-card {
                padding: 14px;
            }
            
            .stat-card .stat-value {
                font-size: 24px;
            }
            
            .stat-card .stat-label {
                font-size: 10px;
            }
            
            .stat-icon {
                width: 36px;
                height: 36px;
            }
            
            .filters-section {
                padding: 14px;
                gap: 10px;
                border-radius: 16px;
            }
            
            .filter-tabs {
                gap: 4px;
                padding: 3px;
            }
            
            .filter-tab {
                padding: 8px 12px;
                font-size: 12px;
            }
            
            .filter-group {
                flex: 1 1 100%;
            }
            
            .filter-group.searchable-dropdown-group {
                flex: 1 1 100%;
            }
            
            .filter-group.date-picker-group {
                flex: 1 1 100%;
            }
            
            .filter-group label {
                font-size: 10px;
            }
            
            .filter-group select,
            .filter-group input {
                padding: 10px 12px;
                font-size: 13px;
            }
            
            .searchable-trigger {
                padding: 10px 12px;
            }
            
            .date-picker-trigger {
                padding: 10px 12px;
                min-width: 100%;
            }
            
            .search-box input {
                padding: 10px 12px 10px 40px;
            }
            
            .dashboard-section {
                padding: 16px;
            }
            
            .dashboard-title {
                font-size: 16px;
            }
            
            th {
                padding: 12px 10px;
                font-size: 10px;
            }
            
            td {
                padding: 12px 10px;
                font-size: 13px;
            }
            
            .customer-info {
                flex-direction: column;
                gap: 2px;
            }
            
            .agent-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 4px;
            }
            
            .agent-avatar {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }
            
            .pagination {
                flex-direction: column;
                gap: 12px;
                align-items: center;
            }
            
            .pagination-info {
                order: 1;
                font-size: 12px;
            }
            
            .pagination-controls {
                order: 0;
            }
            
            .download-modal {
                width: 95%;
                max-height: 90vh;
            }
            
            .download-modal-header {
                padding: 16px;
            }
            
            .download-modal-body {
                padding: 16px;
            }
            
            .download-modal-footer {
                padding: 12px 16px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 0 8px 8px 8px;
            }
            
            .header {
                padding: 12px;
                gap: 12px;
            }
            
            .header-actions {
                gap: 8px;
            }
            
            .refresh-btn,
            .download-btn {
                flex: 1;
                justify-content: center;
                padding: 8px 10px;
                font-size: 11px;
            }
            
            .selection-actions {
                width: 100%;
            }
            
            .selection-btn {
                flex: 1;
                justify-content: center;
                min-width: 0;
                padding: 6px 8px;
                font-size: 11px;
            }
            
            .selection-btn svg {
                display: none;
            }
            
            .stats-grid {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            
            .stat-card {
                padding: 12px;
            }
            
            .stat-card-content {
                flex-direction: column;
                text-align: center;
                gap: 6px;
            }
            
            .stat-card .stat-value {
                font-size: 20px;
            }
            
            .stat-icon {
                margin: 0 auto;
                width: 32px;
                height: 32px;
            }
            
            .filters-section {
                padding: 12px;
                gap: 8px;
                border-radius: 12px;
            }
            
            .filter-tabs {
                flex-direction: row;
                flex-wrap: wrap;
                width: 100%;
                gap: 4px;
            }
            
            .filter-tab {
                flex: 1 1 auto;
                text-align: center;
                padding: 6px 10px;
                font-size: 11px;
            }
            
            .filter-group label {
                font-size: 9px;
            }
            
            .searchable-trigger,
            .date-picker-trigger {
                padding: 8px 10px;
                font-size: 12px;
            }
            
            .searchable-trigger .trigger-text,
            .date-picker-trigger span {
                font-size: 12px;
            }
            
            .search-box input {
                padding: 8px 10px 8px 36px;
                font-size: 12px;
            }
            
            .search-box svg {
                width: 16px;
                height: 16px;
                left: 10px;
            }
            
            .clear-filters-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            
            .conversations-section {
                border-radius: 12px;
            }
            
            .conversations-title {
                font-size: 14px;
            }
            
            .dashboard-section {
                padding: 12px;
                border-radius: 12px;
            }
            
            .dashboard-title {
                font-size: 14px;
            }
            
            .chart-card {
                padding: 12px;
            }
        }

        /* Date Picker Styles */
        .date-picker-group {
            position: relative;
            z-index: 1500;
        }

        .date-picker-trigger {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            background: #fafafa;
            color: #0a0a0a;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 200px;
        }

        .date-picker-trigger:hover {
            border-color: #6366f1;
            background: white;
        }

        .date-picker-trigger svg {
            color: #6366f1;
            flex-shrink: 0;
        }

        .date-picker-trigger .chevron {
            margin-left: auto;
            color: #737373;
            transition: transform 0.2s ease;
        }

        .date-picker-trigger.open .chevron {
            transform: rotate(180deg);
        }

        .date-picker-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: white;
            border: 2px solid #e5e5e5;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 280px;
            overflow: visible;
        }

        .date-picker-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .date-picker-presets {
            padding: 16px;
        }

        .preset-title {
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #a3a3a3;
            margin-bottom: 12px;
        }

        .preset-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            border: none;
            background: transparent;
            text-align: left;
            font-size: 14px;
            font-weight: 600;
            color: #525252;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.15s ease;
            margin-bottom: 2px;
        }

        .preset-btn:hover {
            background: #f5f5f5;
            color: #0a0a0a;
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            color: white;
        }

        .date-picker-divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, #e5e5e5, transparent);
            margin: 0 16px;
        }

        .date-picker-custom {
            padding: 16px;
            background: #fafafa;
            border-radius: 0 0 16px 16px;
            position: relative;
        }

        .custom-date-inputs {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            position: relative;
        }

        .date-input-group {
            flex: 1;
        }

        .date-input-group label {
            display: block;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #737373;
            margin-bottom: 6px;
        }

        .date-input-group input[type="date"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e5e5;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            background: white;
            color: #0a0a0a;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .date-input-group input[type="date"]:hover,
        .date-input-group input[type="date"]:focus {
            border-color: #6366f1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        /* Ensure date picker calendar icon is clickable */
        .date-input-group input[type="date"]::-webkit-calendar-picker-indicator {
            cursor: pointer;
        }

        .apply-custom-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            background: linear-gradient(135deg, #0a0a0a 0%, #262626 100%);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .apply-custom-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .apply-custom-btn:active {
            transform: translateY(0);
        }

        /* Date picker uses document click handler for closing */

        /* Searchable Dropdown Styles */
        .searchable-dropdown-group {
            position: relative;
        }

        .searchable-dropdown {
            position: relative;
        }

        .searchable-trigger {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #fafafa;
            border: 2px solid #e5e5e5;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 180px;
            max-width: 180px;
            height: 46px;
        }

        .searchable-trigger:hover {
            border-color: #d4d4d4;
            background: #fafafa;
        }

        .searchable-trigger.open {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .searchable-trigger .trigger-icon {
            color: #737373;
            flex-shrink: 0;
        }

        .searchable-trigger .trigger-text {
            flex: 1;
            font-size: 13px;
            font-weight: 600;
            color: #0a0a0a;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .searchable-trigger .trigger-chevron {
            color: #737373;
            flex-shrink: 0;
            transition: transform 0.2s ease;
        }

        .searchable-trigger.open .trigger-chevron {
            transform: rotate(180deg);
        }

        .searchable-dropdown-menu {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: white;
            border: 2px solid #e5e5e5;
            border-radius: 12px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.12);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 280px;
            width: max-content;
            max-width: 350px;
        }

        .searchable-dropdown-menu.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .searchable-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            border-bottom: 2px solid #f5f5f5;
            background: #fafafa;
        }

        .searchable-input-wrapper svg {
            color: #a3a3a3;
            flex-shrink: 0;
        }

        .searchable-input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 13px;
            font-weight: 600;
            color: #0a0a0a;
            outline: none;
        }

        .searchable-input::placeholder {
            color: #a3a3a3;
            font-weight: 500;
        }

        .searchable-options {
            max-height: 280px;
            overflow-y: scroll;
            overflow-x: hidden;
            padding: 8px;
            scrollbar-width: thin;
            scrollbar-color: #c4c4c4 #f5f5f5;
        }

        .searchable-options::-webkit-scrollbar {
            width: 8px;
        }

        .searchable-options::-webkit-scrollbar-track {
            background: #f5f5f5;
            border-radius: 4px;
        }

        .searchable-options::-webkit-scrollbar-thumb {
            background: #c4c4c4;
            border-radius: 4px;
            border: 2px solid #f5f5f5;
        }

        .searchable-options::-webkit-scrollbar-thumb:hover {
            background: #a3a3a3;
        }

        .searchable-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .searchable-option:hover {
            background: #f5f5f5;
        }

        .searchable-option span {
            font-size: 13px;
            font-weight: 600;
            color: #525252;
        }

        .searchable-option .check-icon {
            opacity: 0;
            color: #6366f1;
            flex-shrink: 0;
            margin-left: auto;
        }

        .searchable-option.selected {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        }

        .searchable-option.selected span {
            color: #6366f1;
        }

        .searchable-option.selected .check-icon {
            opacity: 1;
        }

        /* Multi-select checkbox styles */
        .searchable-option .multi-checkbox {
            width: 18px;
            height: 18px;
            min-width: 18px;
            border: 2px solid #d4d4d4;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.15s ease;
            background: white;
        }

        .searchable-option .multi-checkbox svg {
            width: 12px;
            height: 12px;
            color: white;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .searchable-option.selected .multi-checkbox {
            background: #6366f1;
            border-color: #6366f1;
        }

        .searchable-option.selected .multi-checkbox svg {
            opacity: 1;
        }

        .searchable-option .option-text {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
            color: #525252;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .searchable-option.selected .option-text {
            color: #6366f1;
            font-weight: 600;
        }

        /* Hover effect on checkbox */
        .searchable-option:hover .multi-checkbox {
            border-color: #a5a5a5;
        }

        .searchable-option.selected:hover .multi-checkbox {
            background: #4f46e5;
            border-color: #4f46e5;
        }

        /* Selected count badge in trigger */
        .trigger-badge {
            background: #6366f1;
            color: white;
            font-size: 11px;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 6px;
        }

        /* Multi-select action buttons */
        .multi-select-actions {
            display: flex;
            gap: 8px;
            padding: 10px 14px;
            border-top: 2px solid #f5f5f5;
            background: #fafafa;
        }

        .multi-select-actions button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .multi-select-actions .clear-btn {
            background: #f5f5f5;
            color: #525252;
        }

        .multi-select-actions .clear-btn:hover {
            background: #e5e5e5;
        }

        .multi-select-actions .apply-btn {
            background: #6366f1;
            color: white;
        }

        .multi-select-actions .apply-btn:hover {
            background: #4f46e5;
        }

        .searchable-option.hidden {
            display: none;
        }

        .searchable-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 16px;
            color: #737373;
            font-size: 13px;
            font-weight: 500;
        }

        .mini-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #e5e5e5;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .searchable-no-results {
            text-align: center;
            padding: 20px;
            color: #a3a3a3;
            font-size: 13px;
            font-weight: 500;
        }

        /* Searchable dropdowns use document click handler for closing */
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="welcome-section">
                <div class="header-icon">
                    <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Chat%20Multiple/SVG/ic_fluent_chat_multiple_32_regular.svg" alt="Conversations" width="32" height="32">
                </div>
                <div class="header-text">
                    <h1>Conversation Records</h1>
                    <p>View and manage all customer conversations across channels</p>
                </div>
            </div>
            <div class="header-actions">
                <button class="refresh-btn" onclick="loadConversations()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
                    </svg>
                    Refresh
                </button>
            </div>
        </div>

        <!-- Download Modal -->
        <div class="download-modal-overlay" id="downloadModal">
            <div class="download-modal">
                <div class="download-modal-header">
                    <h2 id="downloadModalTitle">Download Transcripts</h2>
                    <p id="downloadModalSubtitle">Select format and download conversation transcripts</p>
                </div>
                <div class="download-modal-body">
                    <!-- Format Selection (shown initially) -->
                    <div id="formatSelection">
                        <div class="format-options">
                            <label class="format-option">
                                <input type="radio" name="downloadFormat" value="json" checked>
                                <div class="format-option-content">
                                    <div class="format-option-icon"><img src="https://cdn-icons-png.flaticon.com/512/12419/12419185.png" alt="JSON" style="width: 28px; height: 28px;"></div>
                                    <div class="format-option-details">
                                        <div class="format-option-title">JSON Format</div>
                                        <div class="format-option-desc">Structured data format, ideal for importing into other systems or analysis tools</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="downloadFormat" value="single-txt">
                                <div class="format-option-content">
                                    <div class="format-option-icon"><img src="https://cdn-icons-png.flaticon.com/128/4248/4248321.png" alt="TXT" style="width: 28px; height: 28px;"></div>
                                    <div class="format-option-details">
                                        <div class="format-option-title">Single Text File</div>
                                        <div class="format-option-desc">All transcripts combined into one formatted text file with table of contents</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="downloadFormat" value="multiple-txt">
                                <div class="format-option-content">
                                    <div class="format-option-icon"><img src="https://cdn-icons-png.flaticon.com/128/12075/12075662.png" alt="ZIP" style="width: 28px; height: 28px;"></div>
                                    <div class="format-option-details">
                                        <div class="format-option-title">Separate Text Files (ZIP)</div>
                                        <div class="format-option-desc">Individual text file for each conversation, downloaded as a ZIP archive</div>
                                    </div>
                                </div>
                            </label>
                        </div>
                    </div>
                    <!-- Progress Section (shown during download) -->
                    <div id="downloadProgressSection" style="display: none;">
                        <div class="download-progress">
                            <div class="progress-bar-container">
                                <div class="progress-bar" id="downloadProgressBar"></div>
                            </div>
                            <div class="progress-text" id="downloadProgressText">Ready to download</div>
                        </div>
                        <div class="download-log" id="downloadLog"></div>
                    </div>
                </div>
                <div class="download-modal-footer">
                    <button class="modal-btn modal-btn-secondary" onclick="closeDownloadModal()">Close</button>
                    <button class="modal-btn modal-btn-primary" id="startDownloadBtn" onclick="startTranscriptDownload()">Start Download</button>
                </div>
            </div>
        </div>

        <!-- Assign Agent Modal - Professional Design -->
        <div class="assign-modal-overlay" id="assignAgentModal">
            <div class="assign-modal">
                <div class="assign-modal-header">
                    <div class="assign-modal-header-content">
                        <div class="assign-modal-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
                                <circle cx="9" cy="7" r="4"></circle>
                                <path d="M22 21v-2a4 4 0 0 0-3-3.87"></path>
                                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                            </svg>
                        </div>
                        <h2 class="assign-modal-title" id="assignAgentModalTitle">Assign to Agent</h2>
                        <p class="assign-modal-subtitle" id="assignAgentModalSubtitle">Select an available agent to assign conversations</p>
                    </div>
                </div>
                <div class="assign-modal-body">
                    <!-- Agent Selection -->
                    <div id="agentSelectionSection">
                        <!-- Search Box -->
                        <div class="agent-search-wrapper">
                            <input type="text" class="agent-search-input" id="agentModalSearchInput" placeholder="Search agents by name..." oninput="filterAgentsInModal()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"></circle>
                                <path d="m21 21-4.35-4.35"></path>
                            </svg>
                        </div>
                        
                        <!-- Agent Grid -->
                        <div class="agent-grid" id="agentListContainer">
                            <div class="agent-grid-loading" id="agentListLoading">
                                <div class="spinner-ring"></div>
                                <span>Loading available agents...</span>
                            </div>
                        </div>
                        
                        <!-- Selected Agent Banner -->
                        <div class="selected-agent-banner" id="selectedAgentDisplay">
                            <div class="selected-agent-banner-label">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                                Selected Agent
                            </div>
                            <div class="selected-agent-banner-content" id="selectedAgentInfo"></div>
                        </div>
                    </div>
                    
                    <!-- Assignment Progress Section -->
                    <div class="assign-progress-section" id="assignmentProgressSection">
                        <div class="assign-progress-bar-wrapper">
                            <div class="assign-progress-bar-fill" id="assignmentProgressBar"></div>
                        </div>
                        <div class="assign-progress-text" id="assignmentProgressText">Assigning conversations...</div>
                        <div class="assign-log" id="assignmentLog"></div>
                    </div>
                </div>
                <div class="assign-modal-footer">
                    <button class="assign-btn assign-btn-secondary" onclick="closeAssignAgentModal()">
                        Cancel
                    </button>
                    <button class="assign-btn assign-btn-primary" id="confirmAssignBtn" onclick="confirmAgentAssignment()" disabled>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Assign Conversations
                    </button>
                </div>
            </div>
        </div>

        <!-- Close Conversations Modal -->
        <div class="download-modal-overlay" id="closeConversationsModal">
            <div class="download-modal">
                <div class="download-modal-header" style="background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);">
                    <h2 id="closeConversationsModalTitle">Close Conversations</h2>
                    <p id="closeConversationsModalSubtitle">Close selected conversations</p>
                </div>
                <div class="download-modal-body">
                    <!-- Close Reason Selection -->
                    <div id="closeReasonSection">
                        <div class="close-reason-info">
                            <p style="margin-bottom: 16px; color: #525252; font-size: 14px;">
                                You are about to close <strong id="closeConvCount">0</strong> conversation(s). 
                                Please confirm this action.
                            </p>
                            <div class="close-warning" style="padding: 12px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; margin-bottom: 16px;">
                                <strong style="color: #dc2626;"> Warning:</strong> This action will set the conversation status to closed and cannot be easily undone.
                            </div>
                        </div>
                        
                        <!-- Conversation List Preview -->
                        <div class="close-preview-list" id="closePreviewList" style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; background: #fafafa; margin-bottom: 16px;">
                            <!-- Will be populated with conversation list -->
                        </div>
                    </div>
                    
                    <!-- Close Progress Section -->
                    <div id="closeProgressSection" style="display: none;">
                        <div class="download-progress">
                            <div class="progress-bar-container">
                                <div class="progress-bar" id="closeProgressBar" style="background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);"></div>
                            </div>
                            <div class="progress-text" id="closeProgressText">Closing conversations...</div>
                        </div>
                        <div class="download-log" id="closeLog"></div>
                    </div>
                </div>
                <div class="download-modal-footer">
                    <button class="modal-btn modal-btn-secondary" onclick="closeCloseConversationsModal()">Cancel</button>
                    <button class="modal-btn modal-btn-primary" id="confirmCloseBtn" onclick="confirmCloseConversations()" style="background: #dc2626;">Close Conversations</button>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-grid">
            <div class="stat-card" style="--card-color: #3b82f6; --card-bg: #eff6ff;" onclick="filterByStatus('active', this)">
                <div class="stat-card-content">
                    <div class="stat-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
                        </svg>
                    </div>
                    <div class="stat-info">
                        <div class="stat-value" id="activeCount">-</div>
                        <div class="stat-label">Active</div>
                    </div>
                </div>
            </div>
            <div class="stat-card" style="--card-color: #f59e0b; --card-bg: #fffbeb;" onclick="filterByStatus('waiting', this)">
                <div class="stat-card-content">
                    <div class="stat-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polyline points="12 6 12 12 16 14"></polyline>
                        </svg>
                    </div>
                    <div class="stat-info">
                        <div class="stat-value" id="waitingCount">-</div>
                        <div class="stat-label">Waiting</div>
                    </div>
                </div>
            </div>
            <div class="stat-card" style="--card-color: #a855f7; --card-bg: #faf5ff;" onclick="filterByStatus('wrapup', this)">
                <div class="stat-card-content">
                    <div class="stat-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                        </svg>
                    </div>
                    <div class="stat-info">
                        <div class="stat-value" id="wrapupCount">-</div>
                        <div class="stat-label">Wrap-up</div>
                    </div>
                </div>
            </div>
            <div class="stat-card" style="--card-color: #22c55e; --card-bg: #f0fdf4;" onclick="filterByStatus('closed', this)">
                <div class="stat-card-content">
                    <div class="stat-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                    </div>
                    <div class="stat-info">
                        <div class="stat-value" id="closedCount">-</div>
                        <div class="stat-label">Closed Today</div>
                    </div>
                </div>
            </div>
            <div class="stat-card" style="--card-color: #6b7280; --card-bg: #f9fafb;" onclick="filterByStatus('all', this)">
                <div class="stat-card-content">
                    <div class="stat-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                    </div>
                    <div class="stat-info">
                        <div class="stat-value" id="totalCount">-</div>
                        <div class="stat-label">Total Records</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Filters -->
        <div class="filters-section">
            <div class="filter-tabs">
                <button class="filter-tab active" data-filter="all" onclick="setStatusFilter('all')">All</button>
                <button class="filter-tab" data-filter="ongoing" onclick="setStatusFilter('ongoing')">Ongoing</button>
                <button class="filter-tab" data-filter="closed" onclick="setStatusFilter('closed')">Closed</button>
            </div>
            
            <div class="filter-group searchable-dropdown-group">
                <label>Channel</label>
                <div class="searchable-dropdown" id="channelDropdown">
                    <div class="searchable-trigger" onclick="toggleSearchableDropdown('channel')">
                        <svg class="trigger-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <span class="trigger-text" id="channelTriggerText">All Channels</span>
                        <svg class="trigger-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <div class="searchable-dropdown-menu" id="channelDropdownMenu" onclick="event.stopPropagation()">
                        <div class="searchable-input-wrapper">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                            </svg>
                            <input type="text" class="searchable-input" id="channelSearchInput" placeholder="Type to search channels..." oninput="filterDropdownOptions('channel')">
                        </div>
                        <div class="searchable-options" id="channelOptions">
                            <div class="searchable-loading" id="channelLoading">
                                <div class="mini-spinner"></div>
                                <span>Loading channels...</span>
                            </div>
                        </div>
                        <div class="multi-select-actions">
                            <button class="clear-btn" onclick="clearMultiSelect('channel')">Clear All</button>
                            <button class="apply-btn" onclick="applyMultiSelect('channel')">Apply</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="filter-group searchable-dropdown-group">
                <label>Queue</label>
                <div class="searchable-dropdown" id="queueDropdown">
                    <div class="searchable-trigger" onclick="toggleSearchableDropdown('queue')">
                        <svg class="trigger-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span class="trigger-text" id="queueTriggerText">All Queues</span>
                        <svg class="trigger-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <div class="searchable-dropdown-menu" id="queueDropdownMenu" onclick="event.stopPropagation()">
                        <div class="searchable-input-wrapper">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                            </svg>
                            <input type="text" class="searchable-input" id="queueSearchInput" placeholder="Type to search queues..." oninput="filterDropdownOptions('queue')">
                        </div>
                        <div class="searchable-options" id="queueOptions">
                            <div class="searchable-loading" id="queueLoading">
                                <div class="mini-spinner"></div>
                                <span>Loading queues...</span>
                            </div>
                        </div>
                        <div class="multi-select-actions">
                            <button class="clear-btn" onclick="clearMultiSelect('queue')">Clear All</button>
                            <button class="apply-btn" onclick="applyMultiSelect('queue')">Apply</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="filter-group searchable-dropdown-group">
                <label>Agent</label>
                <div class="searchable-dropdown" id="agentDropdown">
                    <div class="searchable-trigger" onclick="toggleSearchableDropdown('agent')">
                        <svg class="trigger-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                        <span class="trigger-text" id="agentTriggerText">All Agents</span>
                        <svg class="trigger-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <div class="searchable-dropdown-menu" id="agentDropdownMenu" onclick="event.stopPropagation()">
                        <div class="searchable-input-wrapper">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                            </svg>
                            <input type="text" class="searchable-input" id="agentSearchInput" placeholder="Type to search agents..." oninput="filterDropdownOptions('agent')">
                        </div>
                        <div class="searchable-options" id="agentOptions">
                            <div class="searchable-loading" id="agentLoading">
                                <div class="mini-spinner"></div>
                                <span>Loading agents...</span>
                            </div>
                        </div>
                        <div class="multi-select-actions">
                            <button class="clear-btn" onclick="clearMultiSelect('agent')">Clear All</button>
                            <button class="apply-btn" onclick="applyMultiSelect('agent')">Apply</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="filter-group date-picker-group">
                <label>Date Range</label>
                <div class="date-picker-trigger" onclick="toggleDatePicker()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="16" y1="2" x2="16" y2="6"></line>
                        <line x1="8" y1="2" x2="8" y2="6"></line>
                        <line x1="3" y1="10" x2="21" y2="10"></line>
                    </svg>
                    <span id="dateRangeDisplay">Last 30 Days</span>
                    <svg class="chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div class="date-picker-dropdown" id="datePickerDropdown" onclick="event.stopPropagation()">
                    <div class="date-picker-presets">
                        <div class="preset-title">Quick Select</div>
                        <button class="preset-btn" data-preset="today" onclick="selectPreset('today')">Today</button>
                        <button class="preset-btn" data-preset="yesterday" onclick="selectPreset('yesterday')">Yesterday</button>
                        <button class="preset-btn" data-preset="week" onclick="selectPreset('week')">Last 7 Days</button>
                        <button class="preset-btn active" data-preset="month" onclick="selectPreset('month')">Last 30 Days</button>
                        <button class="preset-btn" data-preset="quarter" onclick="selectPreset('quarter')">Last 90 Days</button>
                        <button class="preset-btn" data-preset="year" onclick="selectPreset('year')">Last Year</button>
                        <button class="preset-btn" data-preset="all" onclick="selectPreset('all')">All Time</button>
                    </div>
                    <div class="date-picker-divider"></div>
                    <div class="date-picker-custom">
                        <div class="preset-title">Custom Range</div>
                        <div class="custom-date-inputs">
                            <div class="date-input-group">
                                <label>From</label>
                                <input type="date" id="customStartDate" onchange="updateCustomRange()">
                            </div>
                            <div class="date-input-group">
                                <label>To</label>
                                <input type="date" id="customEndDate" onchange="updateCustomRange()">
                            </div>
                        </div>
                        <button class="apply-custom-btn" onclick="applyCustomRange()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            Apply Range
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="search-box">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <path d="m21 21-4.35-4.35"/>
                </svg>
                <input type="text" id="searchInput" placeholder="Search by conversation ID, customer, agent..." oninput="debounceSearch()">
            </div>
            
            <button class="clear-filters-btn" id="clearFiltersBtn" onclick="clearAllFilters()" style="display: none;" title="Reset all filters to default">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                    <path d="M3 3v5h5"></path>
                </svg>
                Reset Filters
            </button>
        </div>

        <!-- Analytics Dashboard -->
        <div class="dashboard-section" id="dashboardSection">
            <div class="dashboard-header">
                <div class="dashboard-header-left">
                    <div class="dashboard-title">
                        <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Data%20Usage/SVG/ic_fluent_data_usage_48_regular.svg" alt="Analytics" width="20" height="20">
                        Analytics Overview
                    </div>
                    <div class="dashboard-subtitle" id="dashboardSubtitle">Based on filtered conversations</div>
                </div>
                <div class="dashboard-header-right">
                    <button class="dashboard-toggle-btn" onclick="toggleDashboard()" title="Collapse/Expand Analytics">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                        <span id="dashboardToggleText">Collapse</span>
                    </button>
                </div>
            </div>
            <div class="dashboard-charts">
                <!-- Queue Distribution Chart - Horizontal Bar -->
                <div class="chart-card">
                    <div class="chart-header">
                        <span class="chart-title">
                            <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Apps%20List/SVG/ic_fluent_apps_list_32_regular.svg" width="14" height="14" style="margin-right: 6px; opacity: 0.5;" alt="">
                            By Queue
                        </span>
                    </div>
                    <div class="chart-container" id="queueChart"></div>
                    <div class="chart-legend" id="queueLegend"></div>
                </div>
                
                <!-- Agent Distribution Chart - Donut -->
                <div class="chart-card">
                    <div class="chart-header">
                        <span class="chart-title">
                            <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Person/SVG/ic_fluent_person_48_regular.svg" width="14" height="14" style="margin-right: 6px; opacity: 0.5;" alt="">
                            By Agent
                        </span>
                    </div>
                    <div class="chart-with-side-legend">
                        <div class="chart-container" id="agentChart"></div>
                        <div class="chart-side-legend" id="agentLegend"></div>
                    </div>
                </div>
                
                <!-- Channel Distribution Chart - Bubble Pills -->
                <div class="chart-card">
                    <div class="chart-header">
                        <span class="chart-title">
                            <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Calendar%20Mention/SVG/ic_fluent_calendar_mention_20_regular.svg" width="14" height="14" style="margin-right: 6px; opacity: 0.5;" alt="">
                            By Channel
                        </span>
                    </div>
                    <div class="chart-container" id="channelChart"></div>
                    <div class="chart-legend" id="channelLegend"></div>
                </div>
            </div>
        </div>

        <!-- Conversations Table -->
        <div class="conversations-card">
            <div class="conversations-header">
                <div class="conversations-title">
                    <img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Chat%20Multiple/SVG/ic_fluent_chat_multiple_32_regular.svg" alt="Conversations" width="24" height="24">
                    Conversations
                </div>
                <div class="selection-actions" id="selectionActions">
                    <button class="selection-btn" onclick="selectAllFiltered()" title="Select all filtered results">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <path d="m9 12 2 2 4-4"></path>
                        </svg>
                        Select All (<span id="filteredCountDisplay">0</span>)
                    </button>
                    <button class="selection-btn clear-btn" onclick="clearAllSelections()" title="Clear all selections">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="9" y1="9" x2="15" y2="15"></line>
                            <line x1="15" y1="9" x2="9" y2="15"></line>
                        </svg>
                        Clear
                    </button>
                    <button class="selection-btn download-action-btn" id="downloadTranscriptsBtn" onclick="openDownloadModal()" disabled title="Download transcripts for selected conversations">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                        </svg>
                        Download (<span id="selectedCountBadge">0</span>)
                    </button>
                    <button class="selection-btn close-conversations-btn" id="closeConversationsBtn" onclick="closeSelectedConversations()" disabled title="Close selected conversations">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="15" y1="9" x2="9" y2="15"></line>
                            <line x1="9" y1="9" x2="15" y2="15"></line>
                        </svg>
                        Close (<span id="closeCountBadge">0</span>)
                    </button>
                    <button class="selection-btn assign-agent-btn" id="assignAgentBtn" onclick="openAssignAgentModal()" disabled title="Assign selected conversations to an agent">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M16 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <line x1="20" y1="8" x2="20" y2="14"></line>
                            <line x1="23" y1="11" x2="17" y2="11"></line>
                        </svg>
                        Assign (<span id="assignCountBadge">0</span>)
                    </button>
                    <button class="selection-btn reset-columns-btn" onclick="resetColumnOrder()" title="Reset columns to default order">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                            <path d="M3 3v5h5"></path>
                        </svg>
                        Reset Columns
                    </button>
                    <div class="column-selector">
                        <button class="selection-btn columns-btn" onclick="toggleColumnSelector()" title="Choose which columns to display">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"></rect>
                                <rect x="14" y="3" width="7" height="7"></rect>
                                <rect x="3" y="14" width="7" height="7"></rect>
                                <rect x="14" y="14" width="7" height="7"></rect>
                            </svg>
                            Columns
                        </button>
                        <div class="column-selector-dropdown" id="columnSelectorDropdown">
                            <div class="column-selector-header">Show/Hide Columns</div>
                            <div class="column-selector-search">
                                <input type="text" id="columnSearchInput" placeholder="Search columns..." oninput="filterColumnSelector(this.value)">
                            </div>
                            <div class="column-selector-list" id="columnSelectorList">
                                <!-- Populated dynamically -->
                            </div>
                            <div class="column-selector-footer">
                                <button onclick="showAllColumns()">Reset to Default</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="table-container">
                <table>
                    <thead id="tableHeader">
                        <tr>
                            <th class="checkbox-cell">
                                <input type="checkbox" class="select-all-checkbox" id="selectAllCheckbox" onclick="toggleSelectAll(event)" title="Select all on this page">
                            </th>
                            <th class="sortable" onclick="sortBy('workitemid')">ID <span class="sort-icon"></span></th>
                            <th class="sortable" onclick="sortBy('customer')">Customer <span class="sort-icon"></span></th>
                            <th>Channel</th>
                            <th class="sortable" onclick="sortBy('agent')">Agent <span class="sort-icon"></span></th>
                            <th>Queue</th>
                            <th class="sortable" onclick="sortBy('status')">Status <span class="sort-icon"></span></th>
                            <th class="sortable" onclick="sortBy('createdon')">Started <span class="sort-icon"></span></th>
                            <th class="sortable" onclick="sortBy('duration')">Duration <span class="sort-icon"></span></th>
                            <th>Workstream</th>
                        </tr>
                    </thead>
                    <tbody id="conversationsTable">
                        <tr>
                            <td colspan="10">
                                <div class="loading">
                                    <div class="spinner"></div>
                                    <p>Loading conversations...</p>
                                </div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="pagination">
                <div class="pagination-info">
                    Showing <span id="showingStart">0</span>-<span id="showingEnd">0</span> of <span id="totalRecords">0</span> conversations
                </div>
                <div class="pagination-controls">
                    <div class="page-size-selector">
                        <label for="pageSizeSelect">Rows per page:</label>
                        <select id="pageSizeSelect" onchange="changePageSize(this.value)">
                            <option value="25">25</option>
                            <option value="50">50</option>
                            <option value="100">100</option>
                        </select>
                    </div>
                    <button class="page-btn" id="prevBtn" onclick="previousPage()" disabled> Previous</button>
                    <button class="page-btn" id="nextBtn" onclick="nextPage()" disabled>Next </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allConversations = [];
        let filteredConversations = [];
        let selectedConversations = new Set(); // Track selected conversation IDs
        let currentPage = 1;
        let pageSize = 25;
        
        // Utility function: Generate a color from a string (for avatar backgrounds)
        function getColorForString(str) {
            if (!str) return '#94a3b8';
            
            // Predefined color palette for avatars
            const colors = [
                '#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#6366f1',
                '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#06b6d4',
                '#84cc16', '#a855f7', '#f43f5e', '#22c55e', '#eab308'
            ];
            
            // Simple hash function
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            return colors[Math.abs(hash) % colors.length];
        }
        
        // Get Xrm context helper
        function getXrmContext() {
            if (typeof Xrm !== 'undefined' && Xrm.WebApi) {
                return Xrm;
            } else if (typeof parent !== 'undefined' && parent.Xrm && parent.Xrm.WebApi) {
                return parent.Xrm;
            } else if (typeof window.parent !== 'undefined' && window.parent.Xrm && window.parent.Xrm.WebApi) {
                return window.parent.Xrm;
            }
            console.error('Xrm context not available');
            return null;
        }
        let currentStatusFilter = 'all';
        let sortColumn = 'createdon';
        let sortDirection = 'desc';
        let searchTimeout = null;
        let xrmGlobal = null;
        let currentUser = null;
        let currentDateFilter = 'all'; // Default to 'All Time' for first-time users
        let customStartDate = null;
        let customEndDate = null;
        
        // LocalStorage keys for persisting user preferences
        const STORAGE_KEYS = {
            DATE_FILTER: 'advConv_dateFilter',
            CUSTOM_START: 'advConv_customStartDate',
            CUSTOM_END: 'advConv_customEndDate',
            SORT_COLUMN: 'advConv_sortColumn',
            SORT_DIRECTION: 'advConv_sortDirection'
        };
        
        // Load saved preferences from localStorage
        function loadSavedPreferences() {
            try {
                const savedDateFilter = localStorage.getItem(STORAGE_KEYS.DATE_FILTER);
                const savedCustomStart = localStorage.getItem(STORAGE_KEYS.CUSTOM_START);
                const savedCustomEnd = localStorage.getItem(STORAGE_KEYS.CUSTOM_END);
                const savedSortColumn = localStorage.getItem(STORAGE_KEYS.SORT_COLUMN);
                const savedSortDirection = localStorage.getItem(STORAGE_KEYS.SORT_DIRECTION);
                const savedPageSize = localStorage.getItem('advConv_pageSize');
                
                if (savedDateFilter) {
                    currentDateFilter = savedDateFilter;
                    if (savedDateFilter === 'custom') {
                        customStartDate = savedCustomStart;
                        customEndDate = savedCustomEnd;
                    }
                }
                
                if (savedSortColumn) {
                    sortColumn = savedSortColumn;
                }
                
                if (savedSortDirection) {
                    sortDirection = savedSortDirection;
                }
                
                if (savedPageSize) {
                    pageSize = parseInt(savedPageSize, 10);
                    // Update the dropdown to reflect saved value
                    const pageSizeSelect = document.getElementById('pageSizeSelect');
                    if (pageSizeSelect) {
                        pageSizeSelect.value = pageSize;
                    }
                }
                
                console.log('Loaded preferences:', { currentDateFilter, sortColumn, sortDirection, pageSize });
            } catch (e) {
                console.warn('Could not load preferences from localStorage:', e);
            }
        }
        
        // Save date filter preference
        function saveDateFilterPreference() {
            try {
                localStorage.setItem(STORAGE_KEYS.DATE_FILTER, currentDateFilter);
                if (currentDateFilter === 'custom') {
                    if (customStartDate) localStorage.setItem(STORAGE_KEYS.CUSTOM_START, customStartDate);
                    if (customEndDate) localStorage.setItem(STORAGE_KEYS.CUSTOM_END, customEndDate);
                } else {
                    localStorage.removeItem(STORAGE_KEYS.CUSTOM_START);
                    localStorage.removeItem(STORAGE_KEYS.CUSTOM_END);
                }
            } catch (e) {
                console.warn('Could not save date filter preference:', e);
            }
        }
        
        // Save sort preference
        function saveSortPreference() {
            try {
                localStorage.setItem(STORAGE_KEYS.SORT_COLUMN, sortColumn);
                localStorage.setItem(STORAGE_KEYS.SORT_DIRECTION, sortDirection);
            } catch (e) {
                console.warn('Could not save sort preference:', e);
            }
        }
        
        // Update UI elements to reflect saved preferences
        function updateUIFromSavedPreferences() {
            // Update date filter display
            const displayTexts = {
                'today': 'Today',
                'yesterday': 'Yesterday',
                'week': 'Last 7 Days',
                'month': 'Last 30 Days',
                'quarter': 'Last 90 Days',
                'year': 'Last Year',
                'all': 'All Time',
                'custom': 'Custom Range'
            };
            
            const dateRangeDisplay = document.getElementById('dateRangeDisplay');
            if (dateRangeDisplay) {
                if (currentDateFilter === 'custom' && customStartDate) {
                    const startStr = new Date(customStartDate).toLocaleDateString();
                    const endStr = customEndDate ? new Date(customEndDate).toLocaleDateString() : 'Now';
                    dateRangeDisplay.textContent = `${startStr} - ${endStr}`;
                } else {
                    dateRangeDisplay.textContent = displayTexts[currentDateFilter] || 'All Time';
                }
            }
            
            // Update preset button active states
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === currentDateFilter);
            });
            
            // Update custom date inputs if custom range was saved
            if (currentDateFilter === 'custom') {
                const startInput = document.getElementById('customStartDate');
                const endInput = document.getElementById('customEndDate');
                if (startInput && customStartDate) startInput.value = customStartDate;
                if (endInput && customEndDate) endInput.value = customEndDate;
            }
            
            console.log('UI updated with saved preferences:', { currentDateFilter, sortColumn, sortDirection });
        }
        let isDownloading = false;

        // Entity metadata - will be populated dynamically
        let entityMetadata = null;
        let dynamicFields = []; // Fields discovered from metadata
        
        // Column configuration - order can be changed by dragging
        // Base columns that have special rendering (always available)
        const baseColumns = [
            'checkbox', 'id', 'fullId', 'customer', 'title', 'channel', 'agent', 'queue', 'status', 
            'started', 'closed', 'duration', 'workstream', 'modifiedon', 'state', 'statusreason', 'sentiment'
        ];
        
        // All available columns - will be expanded with dynamic fields
        let allAvailableColumns = [...baseColumns];
        const defaultColumnOrder = ['checkbox', 'customer', 'channel', 'agent', 'queue', 'status', 'started', 'duration', 'workstream'];
        let columnOrder = [...allAvailableColumns]; // Use all available for ordering
        
        // Column visibility - which columns are shown (default shows the main ones)
        const defaultVisibleColumns = ['checkbox', 'customer', 'channel', 'agent', 'queue', 'status', 'started', 'duration', 'workstream'];
        let visibleColumns = new Set(defaultVisibleColumns);

        // Column definitions
        const columnDefinitions = {
            checkbox: {
                id: 'checkbox',
                displayName: 'Select',
                header: () => `<input type="checkbox" class="select-all-checkbox" id="selectAllCheckbox" onclick="toggleSelectAll(event)" title="Select all on this page">`,
                sortable: false,
                draggable: false,
                hideable: false, // Cannot hide checkbox column
                cssClass: 'checkbox-cell',
                render: (ctx) => `<td class="checkbox-cell" onclick="event.stopPropagation()"><input type="checkbox" class="conv-checkbox" data-id="${ctx.conv.id}" ${ctx.isSelected ? 'checked' : ''} onchange="toggleConversationSelection('${ctx.conv.id}', this.checked)"></td>`
            },
            id: {
                id: 'id',
                displayName: 'ID',
                header: () => `ID <span class="sort-icon"></span>`,
                sortKey: 'workitemid',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="conversation-id">${ctx.conv.workitemid}</span></td>`
            },
            customer: {
                id: 'customer',
                displayName: 'Customer',
                header: () => `Customer <span class="sort-icon"></span>`,
                sortKey: 'customer',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><div class="customer-info"><span class="customer-name">${escapeHtml(ctx.conv.customerName)}</span><span class="customer-channel">${escapeHtml(ctx.conv.title)}</span></div></td>`
            },
            channel: {
                id: 'channel',
                displayName: 'Channel',
                header: () => `Channel`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="channel-badge">${ctx.channel.name}</span></td>`
            },
            agent: {
                id: 'agent',
                displayName: 'Agent',
                header: () => `Agent <span class="sort-icon"></span>`,
                sortKey: 'agent',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><div class="agent-info"><div class="agent-avatar">${ctx.avatarContent}</div><span class="agent-name">${escapeHtml(ctx.conv.agentName)}</span></div></td>`
            },
            queue: {
                id: 'queue',
                displayName: 'Queue',
                header: () => `Queue`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="queue-badge">${escapeHtml(ctx.conv.queueName)}</span></td>`
            },
            status: {
                id: 'status',
                displayName: 'Status',
                header: () => `Status <span class="sort-icon"></span>`,
                sortKey: 'status',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="status-badge status-${ctx.status.class}">${ctx.status.label}</span></td>`
            },
            started: {
                id: 'started',
                displayName: 'Started',
                header: () => `Started <span class="sort-icon"></span>`,
                sortKey: 'createdon',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><div class="date-cell"><div class="time">${ctx.createdDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div>${ctx.createdDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div></div></td>`
            },
            duration: {
                id: 'duration',
                displayName: 'Duration',
                header: () => `Duration <span class="sort-icon"></span>`,
                sortKey: 'duration',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="duration-cell">${formatDuration(ctx.conv)}</span></td>`
            },
            workstream: {
                id: 'workstream',
                displayName: 'Workstream',
                header: () => `Workstream`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="workstream-badge" title="${escapeHtml(ctx.conv.workstreamName)}">${escapeHtml(ctx.conv.workstreamName)}</span></td>`
            },
            fullId: {
                id: 'fullId',
                displayName: 'Full ID (GUID)',
                header: () => `Full ID`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span class="conversation-id" style="font-size: 11px;" title="${ctx.conv.id}">${ctx.conv.id}</span></td>`
            },
            title: {
                id: 'title',
                displayName: 'Title',
                header: () => `Title`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => `<td onclick="openConversation('${ctx.conv.id}')"><span title="${escapeHtml(ctx.conv.title)}">${escapeHtml(ctx.conv.title)}</span></td>`
            },
            closed: {
                id: 'closed',
                displayName: 'Closed On',
                header: () => `Closed On <span class="sort-icon"></span>`,
                sortKey: 'closedon',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => {
                    if (!ctx.conv.closedon) {
                        return `<td onclick="openConversation('${ctx.conv.id}')"><span class="text-muted">-</span></td>`;
                    }
                    const closedDate = new Date(ctx.conv.closedon);
                    return `<td onclick="openConversation('${ctx.conv.id}')"><div class="date-cell"><div class="time">${closedDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div>${closedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div></div></td>`;
                }
            },
            modifiedon: {
                id: 'modifiedon',
                displayName: 'Modified On',
                header: () => `Modified On <span class="sort-icon"></span>`,
                sortKey: 'modifiedon',
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => {
                    if (!ctx.conv.modifiedon) {
                        return `<td onclick="openConversation('${ctx.conv.id}')"><span class="text-muted">-</span></td>`;
                    }
                    const modifiedDate = new Date(ctx.conv.modifiedon);
                    return `<td onclick="openConversation('${ctx.conv.id}')"><div class="date-cell"><div class="time">${modifiedDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })}</div><div>${modifiedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div></div></td>`;
                }
            },
            state: {
                id: 'state',
                displayName: 'State',
                header: () => `State`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => {
                    const stateLabels = { 0: 'Open', 1: 'Closed' };
                    const stateLabel = stateLabels[ctx.conv.statecode] || 'Unknown';
                    return `<td onclick="openConversation('${ctx.conv.id}')"><span>${stateLabel}</span></td>`;
                }
            },
            statusreason: {
                id: 'statusreason',
                displayName: 'Status Reason',
                header: () => `Status Reason`,
                sortable: false,
                draggable: true,
                hideable: true,
                render: (ctx) => {
                    const statusReasonLabels = {
                        1: 'Open', 2: 'Active', 3: 'Waiting', 4: 'Wrap-up',
                        5: 'Closed', 6: 'Resolved', 7: 'Timeout', 8: 'Escalated',
                        9: 'Transferred', 192350000: 'Agent Assigned', 192350001: 'Queue Assigned',
                        192350002: 'Consult', 192350003: 'Monitor', 192350004: 'Agent Disconnected'
                    };
                    const label = statusReasonLabels[ctx.conv.statuscode] || ctx.conv.statuscode || '-';
                    return `<td onclick="openConversation('${ctx.conv.id}')"><span>${label}</span></td>`;
                }
            },
            sentiment: {
                id: 'sentiment',
                displayName: 'Sentiment',
                header: () => `Sentiment`,
                sortable: true,
                draggable: true,
                hideable: true,
                render: (ctx) => {
                    // Using Twemoji (Twitter's colored emoji set) for expressive sentiment visualization
                    const sentimentMapping = {
                        0:  { label: 'N/A', class: 'na', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/26aa.svg' },
                        7:  { label: 'Very negative', class: 'very-negative', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f621.svg' },
                        8:  { label: 'Negative', class: 'negative', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f61f.svg' },
                        9:  { label: 'Slightly negative', class: 'slightly-negative', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f615.svg' },
                        10: { label: 'Neutral', class: 'neutral', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f610.svg' },
                        11: { label: 'Slightly positive', class: 'slightly-positive', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f642.svg' },
                        12: { label: 'Positive', class: 'positive', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f60a.svg' },
                        13: { label: 'Very positive', class: 'very-positive', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f604.svg' }
                    };
                    
                    const sentimentValue = ctx.conv.msdyn_customersentimentlabel;
                    const formattedValue = ctx.conv.dynamicFieldsFormatted?.msdyn_customersentimentlabel;
                    
                    // Use picklist value if available
                    if (sentimentValue !== null && sentimentValue !== undefined) {
                        const sentiment = sentimentMapping[sentimentValue] || { label: 'Unknown', class: 'neutral', icon: 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/2753.svg' };
                        return `<td onclick="openConversation('${ctx.conv.id}')"><span class="sentiment-badge sentiment-${sentiment.class}" title="${escapeHtml(sentiment.label)}"><img src="${sentiment.icon}" alt="" class="sentiment-icon" /> ${sentiment.label}</span></td>`;
                    }
                    
                    // If we have the formatted value but not the numeric value, use it directly
                    if (formattedValue) {
                        const labelLower = formattedValue.toLowerCase();
                        let sentimentClass = 'neutral';
                        let icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f610.svg';
                        
                        if (labelLower.includes('very positive')) {
                            sentimentClass = 'very-positive'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f604.svg';
                        } else if (labelLower.includes('positive') && !labelLower.includes('slightly')) {
                            sentimentClass = 'positive'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f60a.svg';
                        } else if (labelLower.includes('slightly positive')) {
                            sentimentClass = 'slightly-positive'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f642.svg';
                        } else if (labelLower.includes('very negative')) {
                            sentimentClass = 'very-negative'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f621.svg';
                        } else if (labelLower.includes('negative') && !labelLower.includes('slightly')) {
                            sentimentClass = 'negative'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f61f.svg';
                        } else if (labelLower.includes('slightly negative')) {
                            sentimentClass = 'slightly-negative'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f615.svg';
                        } else if (labelLower === 'n/a') {
                            sentimentClass = 'na'; icon = 'https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/26aa.svg';
                        }
                        
                        return `<td onclick="openConversation('${ctx.conv.id}')"><span class="sentiment-badge sentiment-${sentimentClass}" title="${escapeHtml(formattedValue)}"><img src="${icon}" alt="" class="sentiment-icon" /> ${formattedValue}</span></td>`;
                    }
                    
                    // Default to N/A
                    const sentiment = sentimentMapping[0];
                    return `<td onclick="openConversation('${ctx.conv.id}')"><span class="sentiment-badge sentiment-${sentiment.class}" title="${sentiment.label}"><img src="${sentiment.icon}" alt="" class="sentiment-icon" /> ${sentiment.label}</span></td>`;
                }
            }
        };

        // Fields that are already handled by base columns (don't duplicate)
        const handledFields = [
            'msdyn_ocliveworkitemid', 'msdyn_channel', 'statuscode', 'statecode', 
            'createdon', 'modifiedon', 'msdyn_closedon', 'msdyn_title',
            '_msdyn_activeagentid_value', '_msdyn_cdsqueueid_value', 
            '_msdyn_liveworkstreamid_value', '_msdyn_customer_value',
            'msdyn_customersentimentlabel'
        ];

        // Fetch entity metadata to discover all available fields
        async function fetchEntityMetadata() {
            try {
                const xrm = window.parent.Xrm;
                if (!xrm) {
                    console.log('Xrm not available for metadata fetch');
                    return;
                }

                console.log('Fetching entity metadata for msdyn_ocliveworkitem...');
                
                // Use getEntityMetadata to get all attributes
                const metadata = await xrm.Utility.getEntityMetadata("msdyn_ocliveworkitem");
                entityMetadata = metadata;
                
                console.log('Entity metadata loaded:', metadata);
                console.log('Attributes:', metadata.Attributes);
                
                // Process attributes and create dynamic columns
                if (metadata.Attributes) {
                    const attributes = metadata.Attributes.getAll ? metadata.Attributes.getAll() : 
                                       (Array.isArray(metadata.Attributes) ? metadata.Attributes : Object.values(metadata.Attributes));
                    
                    console.log('Processing', attributes.length, 'attributes');
                    
                    attributes.forEach(attr => {
                        const logicalName = attr.LogicalName || attr.logicalName;
                        const displayName = attr.DisplayName || attr.displayName || logicalName;
                        const attrType = attr.AttributeType || attr.attributeType;
                        
                        // Skip if already handled by base columns
                        if (handledFields.includes(logicalName)) return;
                        // Skip system fields
                        if (logicalName.startsWith('versionnumber') || 
                            logicalName.startsWith('ownerid') ||
                            logicalName === 'timezoneruleversionnumber' ||
                            logicalName === 'utcconversiontimezonecode' ||
                            logicalName === 'importsequencenumber' ||
                            logicalName === 'overriddencreatedon') return;
                        
                        // Create column ID from logical name
                        const columnId = 'dyn_' + logicalName;
                        
                        // Skip if column already exists
                        if (columnDefinitions[columnId]) return;
                        
                        // Store field info for API query
                        dynamicFields.push({
                            logicalName: logicalName,
                            displayName: typeof displayName === 'object' ? (displayName.UserLocalizedLabel?.Label || logicalName) : displayName,
                            attributeType: attrType,
                            columnId: columnId
                        });
                        
                        // Add to available columns
                        allAvailableColumns.push(columnId);
                        
                        // Create dynamic column definition
                        const fieldDisplayName = typeof displayName === 'object' ? 
                            (displayName.UserLocalizedLabel?.Label || logicalName) : displayName;
                        
                        columnDefinitions[columnId] = {
                            id: columnId,
                            displayName: fieldDisplayName,
                            logicalName: logicalName,
                            attributeType: attrType,
                            header: () => escapeHtml(fieldDisplayName),
                            sortable: false,
                            draggable: true,
                            hideable: true,
                            render: (ctx) => {
                                const value = ctx.conv.dynamicFields?.[logicalName];
                                const formattedValue = ctx.conv.dynamicFieldsFormatted?.[logicalName];
                                
                                // Use formatted value if available, otherwise raw value
                                let displayValue = formattedValue || value;
                                
                                if (displayValue === null || displayValue === undefined) {
                                    return `<td onclick="openConversation('${ctx.conv.id}')"><span class="text-muted">-</span></td>`;
                                }
                                
                                // Handle dates
                                if (attrType === 2 || (typeof displayValue === 'string' && displayValue.match(/^\d{4}-\d{2}-\d{2}T/))) {
                                    try {
                                        const date = new Date(displayValue);
                                        if (!isNaN(date.getTime())) {
                                            displayValue = date.toLocaleString();
                                        }
                                    } catch (e) {}
                                }
                                
                                // Handle booleans
                                if (typeof displayValue === 'boolean') {
                                    displayValue = displayValue ? 'Yes' : 'No';
                                }
                                
                                // Escape HTML for safety
                                const escapedValue = escapeHtml(String(displayValue));
                                
                                return `<td onclick="openConversation('${ctx.conv.id}')"><span title="${escapedValue}">${escapedValue}</span></td>`;
                            }
                        };
                    });
                    
                    console.log('Created', dynamicFields.length, 'dynamic columns');
                    console.log('Total columns available:', allAvailableColumns.length);
                }
                
                // Update column order to include new columns
                columnOrder = [...allAvailableColumns];
                
            } catch (error) {
                console.error('Error fetching entity metadata:', error);
            }
        }

        // Build dynamic select fields for API query
        function buildDynamicSelectFields() {
            // Base fields we always need
            const baseSelectFields = [
                'msdyn_ocliveworkitemid', 'msdyn_channel', 'statuscode', 'statecode',
                'createdon', 'modifiedon', 'msdyn_closedon', 'msdyn_title',
                '_msdyn_activeagentid_value', '_msdyn_cdsqueueid_value',
                '_msdyn_liveworkstreamid_value', '_msdyn_customer_value',
                'msdyn_customersentimentlabel'
            ];
            
            // Note: Sentiment fields may show N/A if sentiment analysis is not enabled
            
            // Add visible dynamic fields
            const dynamicSelectFields = dynamicFields
                .filter(f => visibleColumns.has(f.columnId))
                .map(f => f.logicalName);
            
            return [...baseSelectFields, ...dynamicSelectFields].join(',');
        }

        // Load column order from localStorage
        function loadColumnOrder() {
            try {
                const saved = localStorage.getItem('conversationColumnOrder');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate columns exist in allAvailableColumns and filter out deprecated 'id' column
                    const validColumns = parsed.filter(col => col !== 'id' && allAvailableColumns.includes(col));
                    // Add any missing columns at the end
                    const missingColumns = allAvailableColumns.filter(col => !validColumns.includes(col));
                    columnOrder = [...validColumns, ...missingColumns];
                }
            } catch (e) {
                console.log('Could not load column order from localStorage');
            }
        }

        // Save column order to localStorage
        function saveColumnOrder() {
            try {
                localStorage.setItem('conversationColumnOrder', JSON.stringify(columnOrder));
            } catch (e) {
                console.log('Could not save column order to localStorage');
            }
        }
        
        // Load column visibility from localStorage
        function loadColumnVisibility() {
            try {
                const saved = localStorage.getItem('conversationVisibleColumns');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate columns exist in allAvailableColumns (includes dynamic columns)
                    // Also filter out deprecated 'id' column
                    const validColumns = parsed.filter(col => 
                        col !== 'id' && (allAvailableColumns.includes(col) || col.startsWith('dyn_'))
                    );
                    // Always include checkbox
                    if (!validColumns.includes('checkbox')) {
                        validColumns.unshift('checkbox');
                    }
                    visibleColumns = new Set(validColumns);
                }
            } catch (e) {
                console.log('Could not load column visibility from localStorage');
            }
        }
        
        // Save column visibility to localStorage
        function saveColumnVisibility() {
            try {
                localStorage.setItem('conversationVisibleColumns', JSON.stringify([...visibleColumns]));
            } catch (e) {
                console.log('Could not save column visibility to localStorage');
            }
        }
        
        // Toggle column visibility
        function toggleColumnVisibility(columnId) {
            const col = columnDefinitions[columnId];
            if (!col || col.hideable === false) return;
            
            if (visibleColumns.has(columnId)) {
                visibleColumns.delete(columnId);
            } else {
                visibleColumns.add(columnId);
            }
            
            saveColumnVisibility();
            renderColumnSelector();
            renderTableHeader();
            renderConversations();
        }
        
        // Show all columns
        function showAllColumns() {
            visibleColumns = new Set(defaultVisibleColumns);
            saveColumnVisibility();
            renderColumnSelector();
            renderTableHeader();
            renderConversations();
        }
        
        // Toggle column selector dropdown
        function toggleColumnSelector() {
            const dropdown = document.getElementById('columnSelectorDropdown');
            const button = document.querySelector('.column-selector button');
            const isOpen = dropdown.classList.contains('open');
            
            // Close other dropdowns first
            closeSearchableDropdown();
            closeDatePicker();
            
            if (isOpen) {
                dropdown.classList.remove('open');
            } else {
                renderColumnSelector();
                
                // Position dropdown relative to button
                const rect = button.getBoundingClientRect();
                const dropdownHeight = 500; // approximate max height
                const spaceBelow = window.innerHeight - rect.bottom;
                const spaceAbove = rect.top;
                
                // Position dropdown intelligently
                if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
                    // Show below button
                    dropdown.style.top = (rect.bottom + 8) + 'px';
                } else {
                    // Show above button
                    dropdown.style.top = (rect.top - Math.min(dropdownHeight, spaceAbove - 8)) + 'px';
                }
                dropdown.style.left = (rect.right - 320) + 'px'; // Align right edge
                
                dropdown.classList.add('open');
            }
        }
        
        // Close column selector
        function closeColumnSelector() {
            const dropdown = document.getElementById('columnSelectorDropdown');
            if (dropdown) dropdown.classList.remove('open');
        }
        
        // Render column selector list
        function renderColumnSelector() {
            const list = document.getElementById('columnSelectorList');
            if (!list) return;
            
            // Separate base columns and dynamic columns
            const baseColsToShow = columnOrder.filter(colId => 
                colId !== 'checkbox' && baseColumns.includes(colId)
            );
            const dynamicColsToShow = columnOrder.filter(colId => 
                colId.startsWith('dyn_')
            );
            
            let html = '';
            
            // Base columns section
            if (baseColsToShow.length > 0) {
                html += '<div class="column-selector-group"><div class="column-selector-group-title">Standard Columns</div>';
                html += baseColsToShow.map(colId => {
                    const col = columnDefinitions[colId];
                    if (!col) return '';
                    
                    const isVisible = visibleColumns.has(colId);
                    const isDisabled = col.hideable === false;
                    const disabledClass = isDisabled ? ' disabled' : '';
                    
                    return `
                        <label class="column-selector-item${disabledClass}">
                            <input type="checkbox" 
                                ${isVisible ? 'checked' : ''} 
                                ${isDisabled ? 'disabled' : ''}
                                onchange="toggleColumnVisibility('${colId}')">
                            <span>${col.displayName || colId}</span>
                        </label>
                    `;
                }).join('');
                html += '</div>';
            }
            
            // Dynamic columns section (from entity metadata)
            if (dynamicColsToShow.length > 0) {
                html += '<div class="column-selector-group"><div class="column-selector-group-title">Entity Fields (' + dynamicColsToShow.length + ')</div>';
                html += dynamicColsToShow.map(colId => {
                    const col = columnDefinitions[colId];
                    if (!col) return '';
                    
                    const isVisible = visibleColumns.has(colId);
                    
                    return `
                        <label class="column-selector-item">
                            <input type="checkbox" 
                                ${isVisible ? 'checked' : ''} 
                                onchange="toggleColumnVisibility('${colId}')">
                            <span title="${col.logicalName || colId}">${col.displayName || colId}</span>
                        </label>
                    `;
                }).join('');
                html += '</div>';
            }
            
            if (!html) {
                html = '<div class="column-selector-empty">No columns available</div>';
            }
            
            list.innerHTML = html;
        }
        
        // Filter column selector by search term
        function filterColumnSelector(searchTerm) {
            const list = document.getElementById('columnSelectorList');
            if (!list) return;
            
            const items = list.querySelectorAll('.column-selector-item');
            const groups = list.querySelectorAll('.column-selector-group');
            const term = searchTerm.toLowerCase().trim();
            
            items.forEach(item => {
                const label = item.querySelector('span');
                const text = label ? label.textContent.toLowerCase() : '';
                const title = label ? (label.getAttribute('title') || '').toLowerCase() : '';
                
                if (!term || text.includes(term) || title.includes(term)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Hide group headers if all items in group are hidden
            groups.forEach(group => {
                const visibleItems = group.querySelectorAll('.column-selector-item:not([style*="display: none"])');
                const groupTitle = group.querySelector('.column-selector-group-title');
                if (visibleItems.length === 0 && groupTitle) {
                    group.style.display = 'none';
                } else {
                    group.style.display = '';
                }
            });
        }

        // Reset column order to default
        function resetColumnOrder() {
            columnOrder = [...allAvailableColumns];
            visibleColumns = new Set(defaultVisibleColumns);
            saveColumnOrder();
            saveColumnVisibility();
            renderColumnSelector();
            renderTableHeader();
            renderConversations();
        }

        // Drag and drop state
        let draggedColumn = null;

        // Render table header with draggable columns
        function renderTableHeader() {
            const thead = document.getElementById('tableHeader');
            if (!thead) return;

            // Find or create the tr element
            let tr = thead.querySelector('tr');
            if (!tr) {
                tr = document.createElement('tr');
                thead.appendChild(tr);
            }

            // Only render visible columns
            tr.innerHTML = columnOrder
                .filter(colId => visibleColumns.has(colId))
                .map(colId => {
                const col = columnDefinitions[colId];
                if (!col) return '';

                const classes = [];
                if (col.sortable) classes.push('sortable');
                if (col.draggable) classes.push('draggable');
                if (col.cssClass) classes.push(col.cssClass);
                if (col.sortKey === sortColumn) classes.push('sorted');

                const classAttr = classes.length > 0 ? ` class="${classes.join(' ')}"` : '';
                const draggableAttr = col.draggable ? ' draggable="true"' : '';
                const dataCol = ` data-column="${colId}"`;
                const titleAttr = col.draggable ? ' title="Drag to reorder columns"' : '';
                
                let onclick = '';
                if (col.sortable && col.sortKey) {
                    onclick = ` onclick="sortBy('${col.sortKey}')"`;
                }

                return `<th${classAttr}${draggableAttr}${dataCol}${titleAttr}${onclick}>${col.header()}</th>`;
            }).join('');

            // Setup drag and drop listeners
            setupDragAndDrop();
        }

        // Setup drag and drop event listeners
        function setupDragAndDrop() {
            const headers = document.querySelectorAll('th.draggable');
            
            headers.forEach(header => {
                header.addEventListener('dragstart', handleDragStart);
                header.addEventListener('dragend', handleDragEnd);
                header.addEventListener('dragover', handleDragOver);
                header.addEventListener('dragenter', handleDragEnter);
                header.addEventListener('dragleave', handleDragLeave);
                header.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            draggedColumn = this.dataset.column;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedColumn);
            
            // Add a slight delay to show the dragging state
            setTimeout(() => {
                this.style.opacity = '0.4';
            }, 0);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            this.style.opacity = '';
            
            // Remove all drag-over classes
            document.querySelectorAll('th.draggable').forEach(th => {
                th.classList.remove('drag-over', 'drag-over-left', 'drag-over-right');
            });
            
            draggedColumn = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const targetColumn = this.dataset.column;
            if (targetColumn === draggedColumn) return;

            // Determine if we're on the left or right half of the target
            const rect = this.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            
            this.classList.remove('drag-over-left', 'drag-over-right');
            if (e.clientX < midpoint) {
                this.classList.add('drag-over-left');
            } else {
                this.classList.add('drag-over-right');
            }
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const targetColumn = this.dataset.column;
            if (targetColumn !== draggedColumn) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over', 'drag-over-left', 'drag-over-right');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetColumn = this.dataset.column;
            if (!draggedColumn || targetColumn === draggedColumn) return;

            // Find indices
            const fromIndex = columnOrder.indexOf(draggedColumn);
            const toIndex = columnOrder.indexOf(targetColumn);
            
            if (fromIndex === -1 || toIndex === -1) return;

            // Determine insert position based on where we dropped
            const rect = this.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            const insertBefore = e.clientX < midpoint;

            // Remove from old position
            columnOrder.splice(fromIndex, 1);
            
            // Calculate new position
            let newIndex = columnOrder.indexOf(targetColumn);
            if (!insertBefore) {
                newIndex = newIndex + 1;
            }
            
            // Insert at new position
            columnOrder.splice(newIndex, 0, draggedColumn);

            // Save and re-render
            saveColumnOrder();
            renderTableHeader();
            renderConversations();
            
            // Remove drag classes
            this.classList.remove('drag-over', 'drag-over-left', 'drag-over-right');
        }

        // Channel mapping - Official D365 msdyn_channel values
        // Reference: https://learn.microsoft.com/en-us/dynamics365/customer-service/develop/reference/entities/msdyn_ocliveworkitem
        const channelMap = {
            '19241000': { name: 'Microsoft Teams' },
            '192300000': { name: 'WhatsApp' },
            '192310000': { name: 'LINE' },
            '192320000': { name: 'WeChat' },
            '192330000': { name: 'Facebook' },
            '192340000': { name: 'SMS' },
            '192350000': { name: 'Entity Records' },
            '192350001': { name: 'Twitter' },
            '192350002': { name: 'Custom' },
            '192360000': { name: 'Live Chat' },
            '192370000': { name: 'Voice' },
            '192380000': { name: 'Video' },
            '192390000': { name: 'Co-browse' },
            '192400000': { name: 'Screen Sharing' },
            '192440000': { name: 'Voice Call' },
            '192450000': { name: 'Apple Messages for Business' },
            '192450001': { name: 'Google Business Messages' }
        };
        
        // Store configured channels from the environment
        let configuredChannels = [];
        
        // Multi-select filter state
        let selectedChannels = new Set();
        let selectedQueues = new Set();
        let selectedAgents = new Set();

        // Status mapping
        const statusMap = {
            1: { label: 'Open', class: 'open' },
            2: { label: 'Active', class: 'active' },
            3: { label: 'Waiting', class: 'waiting' },
            4: { label: 'Closed', class: 'closed' },
            5: { label: 'Wrap-up', class: 'wrapup' },
            6: { label: 'Resolved', class: 'closed' },
            7: { label: 'Scheduled', class: 'waiting' }
        };

        // Initialize
        async function initialize() {
            try {
                const xrm = getXrm();
                if (!xrm) {
                    showError();
                    return;
                }

                xrmGlobal = xrm;
                
                // Load saved user preferences from localStorage (date filter, sort)
                loadSavedPreferences();
                
                // Update UI to reflect saved preferences
                updateUIFromSavedPreferences();
                
                // Fetch entity metadata to discover all available fields
                await fetchEntityMetadata();
                
                // Load column order and visibility from localStorage
                loadColumnOrder();
                loadColumnVisibility();
                
                // Load dashboard collapsed state
                loadDashboardState();
                
                // Render the table header with column order
                renderTableHeader();
                
                // Render column selector with all discovered fields
                renderColumnSelector();
                
                // Get current user
                currentUser = await xrm.Utility.getGlobalContext().userSettings;
                
                // Load filter options (including configured channels)
                await Promise.all([
                    loadQueues(xrm),
                    loadAgents(xrm),
                    loadConfiguredChannels(xrm)
                ]);
                
                // Load conversations
                await loadConversations();
                
            } catch (error) {
                console.error('Error initializing:', error);
                showError();
            }
        }

        // Get Xrm from parent window
        function getXrm() {
            if (typeof Xrm !== 'undefined') return Xrm;
            if (window.parent && typeof window.parent.Xrm !== 'undefined') return window.parent.Xrm;
            if (window.top && typeof window.top.Xrm !== 'undefined') return window.top.Xrm;
            return null;
        }

        // Store loaded data for filtering
        let allQueues = [];
        let allAgents = [];

        // Load queues for filter
        async function loadQueues(xrm) {
            try {
                // Query for Omnichannel queues (msdyn_isomnichannelqueue eq true) or all active queues
                const response = await xrm.WebApi.retrieveMultipleRecords(
                    "queue",
                    "?$select=queueid,name&$filter=statecode eq 0&$orderby=name asc&$top=500"
                );
                
                console.log('Queues loaded:', response.entities.length);
                
                allQueues = response.entities.filter(queue => 
                    queue.name && !queue.name.includes('#') && !queue.name.includes('<') && !queue.name.startsWith('$')
                );
                
                const queueOptions = document.getElementById('queueOptions');
                const loading = document.getElementById('queueLoading');
                if (loading) loading.remove();
                
                if (allQueues.length === 0) {
                    const noData = document.createElement('div');
                    noData.className = 'searchable-no-results';
                    noData.textContent = 'No queues available';
                    queueOptions.appendChild(noData);
                    return;
                }
                
                allQueues.forEach(queue => {
                    const option = document.createElement('div');
                    option.className = 'searchable-option';
                    option.setAttribute('data-value', queue.queueid);
                    option.setAttribute('data-name', queue.name.toLowerCase());
                    option.onclick = () => toggleMultiSelectOption('queue', queue.queueid);
                    option.innerHTML = `
                        <div class="multi-checkbox">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <span class="option-text">${escapeHtml(queue.name)}</span>
                    `;
                    queueOptions.appendChild(option);
                });
                
                console.log('Queues displayed:', allQueues.length);
            } catch (error) {
                console.error('Error loading queues:', error);
                const loading = document.getElementById('queueLoading');
                if (loading) {
                    loading.innerHTML = '<span style="color: #ef4444;">Failed to load queues</span>';
                }
            }
        }

        // Map to store agent profile images (base64 data URLs)
        let agentImageMap = {};
        
        // Load agents for filter
        async function loadAgents(xrm) {
            try {
                // Query systemusers with entityimage - returns base64 encoded image data directly
                const response = await xrm.WebApi.retrieveMultipleRecords(
                    "systemuser",
                    "?$select=systemuserid,fullname,entityimage&$filter=isdisabled eq false and accessmode ne 3 and accessmode ne 5&$orderby=fullname asc&$top=500"
                );
                
                console.log('Agents loaded:', response.entities.length);
                
                // Build agent image map - entityimage contains base64 encoded image data
                let agentsWithImages = 0;
                response.entities.forEach(agent => {
                    // entityimage will contain base64 data if the user has a profile picture in Dataverse
                    if (agent.entityimage) {
                        // Create data URL from base64 - D365 stores as JPEG
                        agentImageMap[agent.systemuserid] = `data:image/jpeg;base64,${agent.entityimage}`;
                        agentsWithImages++;
                        console.log('Agent has profile image:', agent.fullname);
                    }
                });
                console.log('Agents with profile images:', agentsWithImages);
                
                allAgents = response.entities.filter(agent => 
                    agent.fullname && 
                    !agent.fullname.includes('#') && 
                    !agent.fullname.toLowerCase().includes('integration') &&
                    !agent.fullname.toLowerCase().includes('system') &&
                    agent.fullname.trim() !== ''
                );
                
                const agentOptions = document.getElementById('agentOptions');
                const loading = document.getElementById('agentLoading');
                if (loading) loading.remove();
                
                // Add "Unassigned" option at the top
                const unassignedOption = document.createElement('div');
                unassignedOption.className = 'searchable-option';
                unassignedOption.setAttribute('data-value', 'unassigned');
                unassignedOption.setAttribute('data-name', 'unassigned');
                unassignedOption.onclick = () => toggleMultiSelectOption('agent', 'unassigned');
                unassignedOption.innerHTML = `
                    <div class="multi-checkbox">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                    </div>
                    <span class="option-text" style="font-style: italic; color: #737373;">Unassigned</span>
                `;
                agentOptions.appendChild(unassignedOption);
                
                if (allAgents.length === 0) {
                    const noData = document.createElement('div');
                    noData.className = 'searchable-no-results';
                    noData.textContent = 'No agents available';
                    agentOptions.appendChild(noData);
                    return;
                }
                
                allAgents.forEach(agent => {
                    const option = document.createElement('div');
                    option.className = 'searchable-option';
                    option.setAttribute('data-value', agent.systemuserid);
                    option.setAttribute('data-name', agent.fullname.toLowerCase());
                    option.onclick = () => toggleMultiSelectOption('agent', agent.systemuserid);
                    option.innerHTML = `
                        <div class="multi-checkbox">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <span class="option-text">${escapeHtml(agent.fullname)}</span>
                    `;
                    agentOptions.appendChild(option);
                });
                
                console.log('Agents displayed:', allAgents.length);
            } catch (error) {
                console.error('Error loading agents:', error);
                const loading = document.getElementById('agentLoading');
                if (loading) {
                    loading.innerHTML = '<span style="color: #ef4444;">Failed to load agents</span>';
                }
            }
        }

        // Load configured channels from the environment
        async function loadConfiguredChannels(xrm) {
            try {
                // Query actual conversations to get unique channel types that exist in the environment
                // This is more reliable than querying workstreams as msdyn_channel on conversations
                // may differ from msdyn_streamsource on workstreams
                const response = await xrm.WebApi.retrieveMultipleRecords(
                    "msdyn_ocliveworkitem",
                    "?$select=msdyn_channel&$top=5000"
                );
                
                console.log('Conversations loaded for channel discovery:', response.entities.length);
                
                // Get unique channel values from actual conversation data
                // Note: Some records may have comma-separated channel values, so we need to split them
                const uniqueChannels = new Set();
                response.entities.forEach(conv => {
                    if (conv.msdyn_channel !== null && conv.msdyn_channel !== undefined) {
                        // Handle both single values and comma-separated values
                        const channelValue = String(conv.msdyn_channel);
                        if (channelValue.includes(',')) {
                            // Split comma-separated values and add each individually
                            channelValue.split(',').forEach(ch => {
                                const trimmed = ch.trim();
                                if (trimmed) uniqueChannels.add(trimmed);
                            });
                        } else {
                            uniqueChannels.add(channelValue);
                        }
                    }
                });
                
                configuredChannels = Array.from(uniqueChannels).sort((a, b) => {
                    // Sort by channel name
                    const nameA = channelMap[a]?.name || 'Unknown';
                    const nameB = channelMap[b]?.name || 'Unknown';
                    return nameA.localeCompare(nameB);
                });
                
                console.log('Discovered channels from conversations:', configuredChannels);
                
                // Populate the channel dropdown with multi-select options
                const channelOptions = document.getElementById('channelOptions');
                const loading = document.getElementById('channelLoading');
                if (loading) loading.remove();
                
                if (configuredChannels.length === 0) {
                    const noData = document.createElement('div');
                    noData.className = 'searchable-no-results';
                    noData.textContent = 'No channels available';
                    channelOptions.appendChild(noData);
                    return;
                }
                
                configuredChannels.forEach(channelValue => {
                    const channelInfo = channelMap[channelValue] || { name: `Channel ${channelValue}` };
                    const option = document.createElement('div');
                    option.className = 'searchable-option';
                    option.setAttribute('data-value', channelValue);
                    option.setAttribute('data-name', channelInfo.name.toLowerCase());
                    option.onclick = () => toggleMultiSelectOption('channel', channelValue);
                    option.innerHTML = `
                        <div class="multi-checkbox">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <span class="option-text">${escapeHtml(channelInfo.name)}</span>
                    `;
                    channelOptions.appendChild(option);
                });
                
                console.log('Channel dropdown populated with', configuredChannels.length, 'channels');
            } catch (error) {
                console.error('Error loading configured channels:', error);
                // Fallback: populate with all known channels
                const channelOptions = document.getElementById('channelOptions');
                const loading = document.getElementById('channelLoading');
                if (loading) loading.remove();
                
                Object.entries(channelMap).forEach(([value, info]) => {
                    const option = document.createElement('div');
                    option.className = 'searchable-option';
                    option.setAttribute('data-value', value);
                    option.setAttribute('data-name', info.name.toLowerCase());
                    option.onclick = () => toggleMultiSelectOption('channel', parseInt(value));
                    option.innerHTML = `
                        <div class="multi-checkbox">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                        <span class="option-text">${escapeHtml(info.name)}</span>
                    `;
                    channelOptions.appendChild(option);
                });
            }
        }

        // Toggle searchable dropdown
        function toggleSearchableDropdown(type) {
            const dropdown = document.getElementById(`${type}Dropdown`);
            const menu = document.getElementById(`${type}DropdownMenu`);
            const trigger = dropdown.querySelector('.searchable-trigger');
            const input = document.getElementById(`${type}SearchInput`);
            
            const isOpen = menu.classList.contains('open');
            
            // Close all other searchable dropdowns first
            document.querySelectorAll('.searchable-dropdown-menu.open').forEach(m => {
                if (m !== menu) m.classList.remove('open');
            });
            document.querySelectorAll('.searchable-trigger.open').forEach(t => {
                if (t !== trigger) t.classList.remove('open');
            });
            
            if (!isOpen) {
                menu.classList.add('open');
                trigger.classList.add('open');
                setTimeout(() => input.focus(), 100);
            } else {
                menu.classList.remove('open');
                trigger.classList.remove('open');
            }
        }

        // Close searchable dropdown
        function closeSearchableDropdown() {
            document.querySelectorAll('.searchable-dropdown-menu.open').forEach(m => m.classList.remove('open'));
            document.querySelectorAll('.searchable-trigger.open').forEach(t => t.classList.remove('open'));
            
            // Clear search inputs
            const queueInput = document.getElementById('queueSearchInput');
            const agentInput = document.getElementById('agentSearchInput');
            if (queueInput) queueInput.value = '';
            if (agentInput) agentInput.value = '';
            
            // Show all options again
            filterDropdownOptions('queue');
            filterDropdownOptions('agent');
        }

        // Filter dropdown options based on search input
        function filterDropdownOptions(type) {
            const input = document.getElementById(`${type}SearchInput`);
            const options = document.getElementById(`${type}Options`);
            const searchText = input.value.toLowerCase().trim();
            
            let visibleCount = 0;
            const allOptions = options.querySelectorAll('.searchable-option');
            
            allOptions.forEach(option => {
                const name = option.getAttribute('data-name') || '';
                const value = option.getAttribute('data-value');
                
                // Always show "All" option if search is empty
                if (value === '' && searchText === '') {
                    option.classList.remove('hidden');
                    visibleCount++;
                } else if (value === '' && searchText !== '') {
                    option.classList.add('hidden');
                } else if (name.includes(searchText)) {
                    option.classList.remove('hidden');
                    visibleCount++;
                } else {
                    option.classList.add('hidden');
                }
            });
            
            // Show no results message
            let noResults = options.querySelector('.searchable-no-results');
            if (visibleCount === 0) {
                if (!noResults) {
                    noResults = document.createElement('div');
                    noResults.className = 'searchable-no-results';
                    noResults.textContent = 'No results found';
                    options.appendChild(noResults);
                }
            } else if (noResults) {
                noResults.remove();
            }
        }

        // Select dropdown option
        function selectDropdownOption(type, value, text) {
            const dropdown = document.getElementById(`${type}Dropdown`);
            const menu = document.getElementById(`${type}DropdownMenu`);
            const trigger = dropdown.querySelector('.searchable-trigger');
            const triggerText = document.getElementById(`${type}TriggerText`);
            const hiddenInput = document.getElementById(`${type}Filter`);
            const options = document.getElementById(`${type}Options`);
            
            // Update trigger text
            triggerText.textContent = text;
            
            // Update hidden input value
            hiddenInput.value = value;
            
            // Update selected state
            options.querySelectorAll('.searchable-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            const selectedOption = options.querySelector(`[data-value="${value}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
            }
            
            // Close this specific dropdown
            menu.classList.remove('open');
            trigger.classList.remove('open');
            
            // Clear the search input
            const searchInput = document.getElementById(`${type}SearchInput`);
            if (searchInput) searchInput.value = '';
            
            // Apply filters
            applyFilters();
        }

        // Toggle multi-select option (checkbox behavior)
        function toggleMultiSelectOption(type, value) {
            const options = document.getElementById(`${type}Options`);
            const option = options.querySelector(`[data-value="${value}"]`);
            
            // Get the appropriate selected set
            let selectedSet;
            if (type === 'channel') selectedSet = selectedChannels;
            else if (type === 'queue') selectedSet = selectedQueues;
            else if (type === 'agent') selectedSet = selectedAgents;
            
            // Toggle selection
            if (selectedSet.has(value)) {
                selectedSet.delete(value);
                option.classList.remove('selected');
            } else {
                selectedSet.add(value);
                option.classList.add('selected');
            }
            
            // Update trigger text to show count
            updateMultiSelectTrigger(type);
        }
        
        // Update the trigger text to show selection count
        function updateMultiSelectTrigger(type) {
            const triggerText = document.getElementById(`${type}TriggerText`);
            
            let selectedSet, allLabel;
            if (type === 'channel') {
                selectedSet = selectedChannels;
                allLabel = 'All Channels';
            } else if (type === 'queue') {
                selectedSet = selectedQueues;
                allLabel = 'All Queues';
            } else if (type === 'agent') {
                selectedSet = selectedAgents;
                allLabel = 'All Agents';
            }
            
            if (selectedSet.size === 0) {
                triggerText.innerHTML = allLabel;
            } else if (selectedSet.size === 1) {
                // Show the name of the single selected item
                const value = Array.from(selectedSet)[0];
                const options = document.getElementById(`${type}Options`);
                const option = options.querySelector(`[data-value="${value}"]`);
                const name = option ? option.querySelector('.option-text')?.textContent : value;
                triggerText.innerHTML = name;
            } else {
                triggerText.innerHTML = `${selectedSet.size} selected`;
            }
        }
        
        // Clear all selections for a multi-select dropdown
        function clearMultiSelect(type) {
            let selectedSet;
            if (type === 'channel') selectedSet = selectedChannels;
            else if (type === 'queue') selectedSet = selectedQueues;
            else if (type === 'agent') selectedSet = selectedAgents;
            
            selectedSet.clear();
            
            // Remove selected class from all options
            const options = document.getElementById(`${type}Options`);
            options.querySelectorAll('.searchable-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Update trigger text
            updateMultiSelectTrigger(type);
        }
        
        // Apply multi-select filter and close dropdown
        function applyMultiSelect(type) {
            const dropdown = document.getElementById(`${type}Dropdown`);
            const menu = document.getElementById(`${type}DropdownMenu`);
            const trigger = dropdown.querySelector('.searchable-trigger');
            
            // Close dropdown
            menu.classList.remove('open');
            trigger.classList.remove('open');
            
            // Clear search input
            const searchInput = document.getElementById(`${type}SearchInput`);
            if (searchInput) searchInput.value = '';
            
            // Show all options again
            const options = document.getElementById(`${type}Options`);
            options.querySelectorAll('.searchable-option').forEach(opt => {
                opt.classList.remove('hidden');
            });
            
            // Apply filters
            applyFilters();
        }

        // Build date filter
        function getDateFilter(forClosedConversations = false) {
            const now = new Date();
            let startDate;
            let endDate = null;
            
            // Use the appropriate date field based on filter type
            const dateField = forClosedConversations ? 'msdyn_closedon' : 'createdon';
            
            // Check if using custom date range
            if (currentDateFilter === 'custom' && customStartDate) {
                startDate = new Date(customStartDate);
                startDate.setHours(0, 0, 0, 0);
                
                if (customEndDate) {
                    endDate = new Date(customEndDate);
                    endDate.setHours(23, 59, 59, 999);
                }
                
                if (endDate) {
                    return `${dateField} ge ${startDate.toISOString()} and ${dateField} le ${endDate.toISOString()}`;
                }
                return `${dateField} ge ${startDate.toISOString()}`;
            }
            
            switch (currentDateFilter) {
                case 'today':
                    startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'yesterday':
                    startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                    endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case 'month':
                    startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                case 'quarter':
                    startDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
                    break;
                case 'year':
                    startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                    break;
                case 'all':
                    return '';
                default:
                    startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            }
            
            if (endDate) {
                return `${dateField} ge ${startDate.toISOString()} and ${dateField} lt ${endDate.toISOString()}`;
            }
            return `${dateField} ge ${startDate.toISOString()}`;
        }

        // Date picker functions
        function toggleDatePicker() {
            const dropdown = document.getElementById('datePickerDropdown');
            const trigger = document.querySelector('.date-picker-trigger');
            
            const isOpen = dropdown.classList.contains('open');
            
            if (isOpen) {
                closeDatePicker();
            } else {
                dropdown.classList.add('open');
                trigger.classList.add('open');
            }
        }

        function closeDatePicker() {
            const dropdown = document.getElementById('datePickerDropdown');
            const trigger = document.querySelector('.date-picker-trigger');
            
            if (dropdown) dropdown.classList.remove('open');
            if (trigger) trigger.classList.remove('open');
        }

        function selectPreset(preset) {
            currentDateFilter = preset;
            customStartDate = null;
            customEndDate = null;
            
            // Save preference to localStorage
            saveDateFilterPreference();
            
            // Update UI
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === preset);
            });
            
            // Update display text
            const displayTexts = {
                'today': 'Today',
                'yesterday': 'Yesterday',
                'week': 'Last 7 Days',
                'month': 'Last 30 Days',
                'quarter': 'Last 90 Days',
                'year': 'Last Year',
                'all': 'All Time'
            };
            document.getElementById('dateRangeDisplay').textContent = displayTexts[preset] || 'All Time';
            
            // Clear custom inputs
            document.getElementById('customStartDate').value = '';
            document.getElementById('customEndDate').value = '';
            
            closeDatePicker();
            applyFilters();
        }

        function updateCustomRange() {
            // Just validate, don't apply yet
            const startInput = document.getElementById('customStartDate');
            const endInput = document.getElementById('customEndDate');
            
            if (startInput.value && endInput.value) {
                const start = new Date(startInput.value);
                const end = new Date(endInput.value);
                
                if (end < start) {
                    endInput.value = startInput.value;
                }
            }
        }

        function applyCustomRange() {
            const startInput = document.getElementById('customStartDate');
            const endInput = document.getElementById('customEndDate');
            
            if (!startInput.value) {
                startInput.focus();
                return;
            }
            
            customStartDate = startInput.value;
            customEndDate = endInput.value || null;
            currentDateFilter = 'custom';
            
            // Save preference to localStorage
            saveDateFilterPreference();
            
            // Update UI - clear preset selection
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Format display text
            const startDate = new Date(customStartDate);
            const formatOptions = { month: 'short', day: 'numeric' };
            let displayText = startDate.toLocaleDateString('en-US', formatOptions);
            
            if (customEndDate) {
                const endDate = new Date(customEndDate);
                displayText += ` - ${endDate.toLocaleDateString('en-US', formatOptions)}`;
            } else {
                displayText += ' onwards';
            }
            
            document.getElementById('dateRangeDisplay').textContent = displayText;
            
            closeDatePicker();
            applyFilters();
        }

        // Close date picker when clicking outside
        document.addEventListener('click', function(e) {
            const datePicker = document.querySelector('.date-picker-group');
            if (datePicker && !datePicker.contains(e.target)) {
                closeDatePicker();
            }
            
            // Close column selector when clicking outside
            const columnSelector = document.querySelector('.column-selector');
            if (columnSelector && !columnSelector.contains(e.target)) {
                closeColumnSelector();
            }
        });

        // Load conversations from D365
        async function loadConversations() {
            const xrm = xrmGlobal || getXrm();
            if (!xrm) {
                showError();
                return;
            }

            try {
                showLoading();
                
                // Build filter
                let filters = [];
                
                // Status filter - use statecode for more reliable filtering
                if (currentStatusFilter === 'ongoing') {
                    // statecode 0 = Open (includes Active, Waiting, Wrap-up)
                    filters.push('statecode eq 0');
                } else if (currentStatusFilter === 'closed') {
                    // statecode 1 = Closed
                    filters.push('statecode eq 1');
                }
                
                // Date filter - for closed conversations, filter by closed date
                const isClosedFilter = currentStatusFilter === 'closed';
                const dateFilter = getDateFilter(isClosedFilter);
                if (dateFilter) filters.push(dateFilter);
                
                // Channel filter - multi-select (msdyn_channel is a string field)
                if (selectedChannels.size > 0) {
                    const channelFilters = Array.from(selectedChannels).map(ch => `msdyn_channel eq '${ch}'`);
                    filters.push(`(${channelFilters.join(' or ')})`);
                }
                
                // Queue filter - multi-select
                if (selectedQueues.size > 0) {
                    const queueFilters = Array.from(selectedQueues).map(q => `_msdyn_cdsqueueid_value eq '${q}'`);
                    filters.push(`(${queueFilters.join(' or ')})`);
                }
                
                // Agent filter - multi-select (handles 'unassigned' special value)
                if (selectedAgents.size > 0) {
                    const agentFiltersArray = [];
                    const hasUnassigned = selectedAgents.has('unassigned');
                    const regularAgents = Array.from(selectedAgents).filter(a => a !== 'unassigned');
                    
                    if (hasUnassigned) {
                        agentFiltersArray.push('_msdyn_activeagentid_value eq null');
                    }
                    
                    regularAgents.forEach(a => {
                        agentFiltersArray.push(`_msdyn_activeagentid_value eq '${a}'`);
                    });
                    
                    filters.push(`(${agentFiltersArray.join(' or ')})`);
                }
                
                const filterString = filters.length > 0 ? `&$filter=${filters.join(' and ')}` : '';
                
                // Query conversations - use formatted value annotations for lookup names
                // Build select with base fields + any visible dynamic fields
                let selectFields = buildDynamicSelectFields();
                let query = `?$select=${selectFields}&$orderby=createdon desc&$top=500${filterString}`;
                
                console.log('Query:', query);
                
                // Try to fetch with full query, fall back to base fields if there's an error
                let response;
                try {
                    response = await xrm.WebApi.retrieveMultipleRecords("msdyn_ocliveworkitem", query);
                } catch (apiError) {
                    // Check if it's a field-not-found error
                    const errorMessage = apiError.message || '';
                    if (errorMessage.includes('Could not find a property') || errorMessage.includes('property named')) {
                        console.warn('Some fields not available, trying with base + sentiment fields:', errorMessage);
                        
                        // First fallback: Try with base fields + sentiment fields
                        const baseWithSentiment = [
                            'msdyn_ocliveworkitemid', 'msdyn_channel', 'statuscode', 'statecode',
                            'createdon', 'modifiedon', 'msdyn_closedon', 'msdyn_title',
                            '_msdyn_activeagentid_value', '_msdyn_cdsqueueid_value',
                            '_msdyn_liveworkstreamid_value', '_msdyn_customer_value',
                            'msdyn_customersentimentlabel', 'msdyn_urcustomersentimentlabel',
                            'msdyn_urcustomersentimentscore', 'msdyn_urcustomersentimentkeywords'
                        ].join(',');
                        
                        query = `?$select=${baseWithSentiment}&$orderby=createdon desc&$top=500${filterString}`;
                        console.log('Fallback query with sentiment:', query);
                        
                        try {
                            response = await xrm.WebApi.retrieveMultipleRecords("msdyn_ocliveworkitem", query);
                        } catch (sentimentError) {
                            // Second fallback: sentiment fields might also not exist
                            console.warn('Sentiment fields not available, using minimal base fields:', sentimentError.message);
                            
                            const baseFieldsOnly = [
                                'msdyn_ocliveworkitemid', 'msdyn_channel', 'statuscode', 'statecode',
                                'createdon', 'modifiedon', 'msdyn_closedon', 'msdyn_title',
                                '_msdyn_activeagentid_value', '_msdyn_cdsqueueid_value',
                                '_msdyn_liveworkstreamid_value', '_msdyn_customer_value'
                            ].join(',');
                            
                            query = `?$select=${baseFieldsOnly}&$orderby=createdon desc&$top=500${filterString}`;
                            console.log('Final fallback query:', query);
                            response = await xrm.WebApi.retrieveMultipleRecords("msdyn_ocliveworkitem", query);
                        }
                    } else {
                        // Re-throw if it's a different kind of error
                        throw apiError;
                    }
                }
                
                // DEBUG: Log the API response to see what fields are returned
                console.log('=== API RESPONSE DEBUG ===');
                console.log('Total records returned:', response.entities.length);
                if (response.entities.length > 0) {
                    const firstRecord = response.entities[0];
                    console.log('First record ID:', firstRecord.msdyn_ocliveworkitemid);
                    console.log('All field names in first record:', Object.keys(firstRecord));
                    console.log('Sentiment fields in first record:', {
                        msdyn_customersentimentlabel: firstRecord.msdyn_customersentimentlabel,
                        msdyn_urcustomersentimentlabel: firstRecord.msdyn_urcustomersentimentlabel,
                        msdyn_urcustomersentimentscore: firstRecord.msdyn_urcustomersentimentscore,
                        msdyn_urcustomersentimentkeywords: firstRecord.msdyn_urcustomersentimentkeywords,
                        // Check for OData formatted values
                        'msdyn_urcustomersentimentlabel_formatted': firstRecord['msdyn_urcustomersentimentlabel@OData.Community.Display.V1.FormattedValue'],
                        'msdyn_customersentimentlabel_formatted': firstRecord['msdyn_customersentimentlabel@OData.Community.Display.V1.FormattedValue']
                    });
                    console.log('Full first record:', firstRecord);
                }
                console.log('=== END API RESPONSE DEBUG ===');
                
                // Get base URL for profile images
                const clientUrl = xrm.Utility.getGlobalContext().getClientUrl();
                
                // Build a map of conversation IDs for queue lookup
                const conversationIds = response.entities.map(c => c.msdyn_ocliveworkitemid).filter(Boolean);
                
                // Fetch queue assignments from queueitem entity
                let queueMap = {};
                if (conversationIds.length > 0) {
                    try {
                        // Query queueitems for these conversations (in batches if needed)
                        const batchSize = 50;
                        for (let i = 0; i < conversationIds.length; i += batchSize) {
                            const batch = conversationIds.slice(i, i + batchSize);
                            const queueFilter = batch.map(id => `_objectid_value eq '${id}'`).join(' or ');
                            const queueItemQuery = `?$select=queueitemid,_objectid_value,_queueid_value&$filter=(${queueFilter})`;
                            const queueItemResponse = await xrm.WebApi.retrieveMultipleRecords("queueitem", queueItemQuery);
                            
                            queueItemResponse.entities.forEach(qi => {
                                if (qi._objectid_value && qi._queueid_value) {
                                    queueMap[qi._objectid_value] = {
                                        queueId: qi._queueid_value,
                                        queueName: qi['_queueid_value@OData.Community.Display.V1.FormattedValue'] || null
                                    };
                                }
                            });
                        }
                        console.log('Queue assignments found:', Object.keys(queueMap).length);
                    } catch (queueError) {
                        console.warn('Could not fetch queue assignments:', queueError);
                    }
                }
                
                allConversations = response.entities.map(conv => {
                    const agentId = conv._msdyn_activeagentid_value;
                    // Use the image URL from agentImageMap - already a full URL
                    const agentImageUrl = agentId && agentImageMap[agentId] ? 
                        agentImageMap[agentId] : 
                        null;
                    
                    // Get queue from queueitem lookup or from direct field
                    const queueFromItem = queueMap[conv.msdyn_ocliveworkitemid];
                    const queueId = conv._msdyn_cdsqueueid_value || queueFromItem?.queueId;
                    const queueName = conv['_msdyn_cdsqueueid_value@OData.Community.Display.V1.FormattedValue'] || 
                                     queueFromItem?.queueName ||
                                     (queueId ? allQueues.find(q => q.queueid === queueId)?.name : null) ||
                                     'N/A';
                    
                    return {
                        id: conv.msdyn_ocliveworkitemid,
                        workitemid: conv.msdyn_ocliveworkitemid ? conv.msdyn_ocliveworkitemid.substring(0, 8).toUpperCase() : 'N/A',
                        title: conv.msdyn_title || 'Conversation',
                        channel: conv.msdyn_channel !== null && conv.msdyn_channel !== undefined ? String(conv.msdyn_channel) : null,
                        statuscode: conv.statuscode,
                        statecode: conv.statecode,
                        createdon: conv.createdon,
                        modifiedon: conv.modifiedon,
                        closedon: conv.msdyn_closedon,
                        workstreamId: conv._msdyn_liveworkstreamid_value,
                        workstreamName: conv['_msdyn_liveworkstreamid_value@OData.Community.Display.V1.FormattedValue'] || 'N/A',
                        agentId: agentId,
                        agentImageUrl: agentImageUrl,
                        // Use OData formatted value annotations for display names
                        agentName: conv['_msdyn_activeagentid_value@OData.Community.Display.V1.FormattedValue'] || 
                                  conv['_msdyn_activeagentid_value@Microsoft.Dynamics.CRM.lookuplogicalname'] || 
                                  'Unassigned',
                        queueId: queueId,
                        queueName: queueName,
                        customerId: conv._msdyn_customer_value,
                        customerName: conv['_msdyn_customer_value@OData.Community.Display.V1.FormattedValue'] || 'Unknown Customer',
                        // Sentiment field
                        msdyn_customersentimentlabel: conv.msdyn_customersentimentlabel,
                        // Store all dynamic fields for dynamic columns
                        dynamicFields: conv,
                        dynamicFieldsFormatted: Object.keys(conv)
                            .filter(key => key.includes('@OData.Community.Display.V1.FormattedValue'))
                            .reduce((acc, key) => {
                                const fieldName = key.replace('@OData.Community.Display.V1.FormattedValue', '');
                                acc[fieldName] = conv[key];
                                return acc;
                            }, {})
                    };
                }).filter(conv => conv.id); // Filter out records without valid IDs
                
                // Check for and remove duplicates (keep first occurrence)
                const seenIds = new Set();
                const duplicateIds = [];
                allConversations = allConversations.filter(conv => {
                    if (seenIds.has(conv.id)) {
                        duplicateIds.push(conv.id);
                        return false;
                    }
                    seenIds.add(conv.id);
                    return true;
                });
                
                if (duplicateIds.length > 0) {
                    console.warn(`Found ${duplicateIds.length} duplicate conversation IDs:`, duplicateIds);
                }
                
                // Apply search filter if any
                applySearchFilter();
                
                // Update stats
                updateStats();
                
                // Update dashboard charts with filtered data
                updateDashboardCharts();
                
                // Render
                renderConversations();
                
            } catch (error) {
                console.error('Error loading conversations:', error);
                document.getElementById('conversationsTable').innerHTML = `
                    <tr>
                        <td colspan="9">
                            <div class="empty-state">
                                <div class="empty-state-icon"></div>
                                <p>Error loading conversations: ${error.message || 'Unknown error'}</p>
                            </div>
                        </td>
                    </tr>
                `;
            }
        }

        // Apply search filter
        function applySearchFilter() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            
            if (!searchTerm) {
                filteredConversations = [...allConversations];
            } else {
                // Remove dashes and brackets from search term for GUID matching
                const cleanSearchTerm = searchTerm.replace(/[-{}]/g, '');
                
                filteredConversations = allConversations.filter(conv => {
                    // Check customer name
                    if (conv.customerName && conv.customerName.toLowerCase().includes(searchTerm)) return true;
                    // Check agent name
                    if (conv.agentName && conv.agentName.toLowerCase().includes(searchTerm)) return true;
                    // Check truncated ID (displayed in table)
                    if (conv.workitemid && conv.workitemid.toLowerCase().includes(searchTerm)) return true;
                    // Check FULL conversation ID (GUID) - with and without dashes
                    if (conv.id && conv.id.toLowerCase().includes(searchTerm)) return true;
                    if (conv.id && conv.id.toLowerCase().replace(/-/g, '').includes(cleanSearchTerm)) return true;
                    // Check title
                    if (conv.title && conv.title.toLowerCase().includes(searchTerm)) return true;
                    // Check queue name
                    if (conv.queueName && conv.queueName.toLowerCase().includes(searchTerm)) return true;
                    // Check workstream name
                    if (conv.workstreamName && conv.workstreamName.toLowerCase().includes(searchTerm)) return true;
                    
                    return false;
                });
            }
            
            // Sort
            sortConversations();
        }

        // Sort conversations
        function sortConversations() {
            filteredConversations.sort((a, b) => {
                let valA, valB;
                
                switch (sortColumn) {
                    case 'workitemid':
                        valA = a.workitemid;
                        valB = b.workitemid;
                        break;
                    case 'customer':
                        valA = a.customerName;
                        valB = b.customerName;
                        break;
                    case 'agent':
                        valA = a.agentName;
                        valB = b.agentName;
                        break;
                    case 'status':
                        valA = a.statuscode;
                        valB = b.statuscode;
                        break;
                    case 'createdon':
                        valA = new Date(a.createdon).getTime();
                        valB = new Date(b.createdon).getTime();
                        break;
                    case 'closedon':
                        valA = a.closedon ? new Date(a.closedon).getTime() : 0;
                        valB = b.closedon ? new Date(b.closedon).getTime() : 0;
                        break;
                    case 'modifiedon':
                        valA = a.modifiedon ? new Date(a.modifiedon).getTime() : 0;
                        valB = b.modifiedon ? new Date(b.modifiedon).getTime() : 0;
                        break;
                    case 'duration':
                        valA = calculateDurationMs(a);
                        valB = calculateDurationMs(b);
                        break;
                    default:
                        valA = a.createdon;
                        valB = b.createdon;
                }
                
                if (typeof valA === 'string') {
                    return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return sortDirection === 'asc' ? valA - valB : valB - valA;
            });
        }

        // Calculate duration in milliseconds
        function calculateDurationMs(conv) {
            const start = new Date(conv.createdon).getTime();
            const end = conv.closedon ? new Date(conv.closedon).getTime() : Date.now();
            return end - start;
        }

        // Format duration
        function formatDuration(conv) {
            const ms = calculateDurationMs(conv);
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours}h ${minutes % 60}m`;
            if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
            return `${seconds}s`;
        }

        // Dashboard color palette - modern, accessible colors
        const chartColors = [
            '#6366f1', // Indigo
            '#ec4899', // Pink
            '#14b8a6', // Teal
            '#f59e0b', // Amber
            '#8b5cf6', // Violet
            '#06b6d4', // Cyan
            '#f97316', // Orange
            '#84cc16', // Lime
            '#ef4444', // Red
            '#3b82f6', // Blue
            '#10b981', // Emerald
            '#a855f7', // Purple
        ];

        // Toggle dashboard collapse state
        function toggleDashboard() {
            const section = document.getElementById('dashboardSection');
            const toggleText = document.getElementById('dashboardToggleText');
            
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            toggleText.textContent = isCollapsed ? 'Expand' : 'Collapse';
            
            // Save preference to localStorage
            localStorage.setItem('dashboardCollapsed', isCollapsed ? 'true' : 'false');
        }

        // Load dashboard collapsed state from localStorage
        function loadDashboardState() {
            const collapsed = localStorage.getItem('dashboardCollapsed');
            if (collapsed === 'true') {
                const section = document.getElementById('dashboardSection');
                const toggleText = document.getElementById('dashboardToggleText');
                if (section) {
                    section.classList.add('collapsed');
                    if (toggleText) toggleText.textContent = 'Expand';
                }
            }
        }

        // Update all dashboard charts
        function updateDashboardCharts() {
            const data = filteredConversations;
            const total = data.length;
            
            // Update subtitle
            const subtitle = document.getElementById('dashboardSubtitle');
            if (subtitle) {
                subtitle.textContent = `Based on ${total} filtered conversation${total !== 1 ? 's' : ''}`;
            }
            
            // Calculate distributions
            const queueDist = calculateDistribution(data, 'queueName');
            const agentDist = calculateDistribution(data, 'agentName');
            const channelDist = calculateDistribution(data, 'channel', (val) => channelMap[val]?.name || 'Unknown');
            
            // Render charts with different types for visual variety
            renderHorizontalBarChart('queueChart', 'queueLegend', queueDist, total);
            renderDonutChart('agentChart', 'agentLegend', agentDist, total);
            renderStackedBarChart('channelChart', 'channelLegend', channelDist, total);
        }

        // Calculate distribution from data
        function calculateDistribution(data, field, labelTransform = null) {
            const counts = {};
            
            data.forEach(item => {
                let value = item[field];
                if (labelTransform) {
                    value = labelTransform(value);
                }
                const label = value || 'Unassigned';
                counts[label] = (counts[label] || 0) + 1;
            });
            
            // Sort by count descending and take top 10
            const sorted = Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            // If there are more than 10, group the rest as "Others"
            if (Object.keys(counts).length > 10) {
                const topLabels = new Set(sorted.map(s => s[0]));
                const othersCount = Object.entries(counts)
                    .filter(([label]) => !topLabels.has(label))
                    .reduce((sum, [, count]) => sum + count, 0);
                if (othersCount > 0) {
                    sorted.push(['Others', othersCount]);
                }
            }
            
            return sorted.map(([label, count], i) => ({
                label,
                count,
                color: chartColors[i % chartColors.length]
            }));
        }

        // Render a horizontal bar chart with smooth animations
        function renderHorizontalBarChart(containerId, legendId, data, total) {
            const container = document.getElementById(containerId);
            const legend = document.getElementById(legendId);
            
            if (!container) return;
            
            // Handle empty data
            if (data.length === 0 || total === 0) {
                container.innerHTML = `
                    <div class="chart-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M12 6v6l4 2"></path>
                        </svg>
                        <span>No data available</span>
                    </div>
                `;
                legend.innerHTML = '';
                return;
            }
            
            const maxCount = Math.max(...data.map(d => d.count));
            
            // Check if bars already exist for update
            const existingBars = container.querySelector('.bar-chart-container');
            
            if (existingBars) {
                // Update existing bars with animation
                data.forEach((item, index) => {
                    const row = existingBars.children[index];
                    if (row) {
                        const percent = (item.count / maxCount) * 100;
                        const barFill = row.querySelector('.bar-fill');
                        const barValue = row.querySelector('.bar-value');
                        const barCount = row.querySelector('.bar-count');
                        const barLabel = row.querySelector('.bar-label');
                        
                        if (barFill) {
                            barFill.style.width = `${percent}%`;
                            barFill.style.background = item.color;
                        }
                        if (barValue) barValue.textContent = `${((item.count / total) * 100).toFixed(0)}%`;
                        if (barCount) barCount.textContent = item.count;
                        if (barLabel) barLabel.textContent = item.label;
                    }
                });
                
                // Remove extra rows
                while (existingBars.children.length > data.length) {
                    existingBars.lastChild.remove();
                }
                
                // Add new rows if needed
                for (let i = existingBars.children.length; i < data.length; i++) {
                    const item = data[i];
                    const percent = (item.count / maxCount) * 100;
                    const row = document.createElement('div');
                    row.className = 'bar-row';
                    row.style.opacity = '0';
                    row.innerHTML = `
                        <span class="bar-label" title="${item.label}">${item.label}</span>
                        <div class="bar-track">
                            <div class="bar-fill" style="width: 0%; background: ${item.color}">
                                <span class="bar-value">${((item.count / total) * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <span class="bar-count">${item.count}</span>
                    `;
                    existingBars.appendChild(row);
                    
                    // Animate new row
                    setTimeout(() => {
                        row.style.transition = 'opacity 0.3s ease';
                        row.style.opacity = '1';
                        row.querySelector('.bar-fill').style.width = `${percent}%`;
                    }, 50);
                }
            } else {
                // Create new chart
                container.innerHTML = '<div class="bar-chart-container"></div>';
                const chartContainer = container.querySelector('.bar-chart-container');
                
                data.forEach((item, index) => {
                    const percent = (item.count / maxCount) * 100;
                    const row = document.createElement('div');
                    row.className = 'bar-row';
                    row.style.opacity = '0';
                    row.style.transform = 'translateX(-10px)';
                    row.innerHTML = `
                        <span class="bar-label" title="${item.label}">${item.label}</span>
                        <div class="bar-track">
                            <div class="bar-fill" style="width: 0%; background: ${item.color}">
                                <span class="bar-value">${((item.count / total) * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <span class="bar-count">${item.count}</span>
                    `;
                    chartContainer.appendChild(row);
                    
                    // Staggered animation
                    setTimeout(() => {
                        row.style.transition = 'opacity 0.4s ease, transform 0.4s ease';
                        row.style.opacity = '1';
                        row.style.transform = 'translateX(0)';
                        
                        setTimeout(() => {
                            row.querySelector('.bar-fill').style.width = `${percent}%`;
                        }, 100);
                    }, index * 60);
                });
            }
            
            // Hide legend for bar chart (info already in bars)
            legend.innerHTML = '';
        }

        // Render a stacked bar chart with smooth animations
        function renderStackedBarChart(containerId, legendId, data, total) {
            const container = document.getElementById(containerId);
            const legend = document.getElementById(legendId);
            
            if (!container) return;
            
            // Handle empty data
            if (data.length === 0 || total === 0) {
                container.innerHTML = `
                    <div class="chart-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M12 6v6l4 2"></path>
                        </svg>
                        <span>No data available</span>
                    </div>
                `;
                legend.innerHTML = '';
                return;
            }
            
            // Build the stacked bar HTML
            let segmentsHtml = '';
            let labelsHtml = '';
            
            data.forEach((item, index) => {
                const percent = (item.count / total) * 100;
                segmentsHtml += `
                    <div class="stacked-bar-segment" 
                         style="width: 0%; background: ${item.color};" 
                         data-width="${percent}"
                         title="${item.label}: ${item.count} (${percent.toFixed(1)}%)">
                    </div>
                `;
                labelsHtml += `
                    <div class="stacked-bar-label" style="opacity: 0;">
                        <span class="stacked-bar-dot" style="background: ${item.color}"></span>
                        <span class="stacked-bar-name">${item.label}</span>
                        <span class="stacked-bar-value">${item.count}</span>
                        <span class="stacked-bar-percent">${percent.toFixed(1)}%</span>
                    </div>
                `;
            });
            
            container.innerHTML = `
                <div class="stacked-bar-chart">
                    <div class="stacked-bar-track">
                        ${segmentsHtml}
                    </div>
                    <div class="stacked-bar-labels">
                        ${labelsHtml}
                    </div>
                </div>
            `;
            
            // Animate segments width
            const segments = container.querySelectorAll('.stacked-bar-segment');
            segments.forEach((segment, index) => {
                setTimeout(() => {
                    segment.style.width = segment.dataset.width + '%';
                }, 100 + (index * 50));
            });
            
            // Animate labels fade in
            const labels = container.querySelectorAll('.stacked-bar-label');
            labels.forEach((label, index) => {
                setTimeout(() => {
                    label.style.transition = 'opacity 0.3s ease';
                    label.style.opacity = '1';
                }, 300 + (index * 40));
            });
            
            // Hide legend (info already shown below bar)
            legend.innerHTML = '';
        }

        // Render a donut chart using D3.js with smooth animations
        function renderDonutChart(containerId, legendId, data, total) {
            const container = document.getElementById(containerId);
            const legend = document.getElementById(legendId);
            
            if (!container) {
                console.error('Donut chart container not found:', containerId);
                return;
            }
            
            // Clear any pending timeouts for this container
            if (container._emptyTimeout) {
                clearTimeout(container._emptyTimeout);
                container._emptyTimeout = null;
            }
            
            // Handle empty data
            if (data.length === 0 || total === 0) {
                container.innerHTML = `
                    <div class="chart-empty">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M12 6v6l4 2"></path>
                        </svg>
                        <span>No data available</span>
                    </div>
                `;
                if (legend) legend.innerHTML = '';
                return;
            }
            
            // Always clear and recreate - simpler and more reliable
            container.innerHTML = '';
            
            // Chart dimensions
            const width = 180;
            const height = 180;
            const margin = 10;
            const radius = Math.min(width, height) / 2 - margin;
            const innerRadius = radius * 0.6;
            
            // Create pie generator
            const pie = d3.pie()
                .value(d => d.count)
                .sort(null)
                .padAngle(0.02);
            
            // Create arc generator
            const arc = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(radius);
            
            // Arc for hover effect
            const arcHover = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(radius + 5);
            
            // Arc for initial animation (starts from center)
            const arcTween = function(d) {
                const interpolate = d3.interpolate({ startAngle: 0, endAngle: 0 }, d);
                return function(t) {
                    return arc(interpolate(t));
                };
            };
            
            // Create new SVG
            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const g = svg.append('g')
                .attr('transform', `translate(${width / 2}, ${height / 2})`);
            
            // Create tooltip (reuse if exists)
            let tooltipEl = d3.select('.chart-tooltip');
            if (tooltipEl.empty()) {
                tooltipEl = d3.select('body')
                    .append('div')
                    .attr('class', 'chart-tooltip')
                    .style('position', 'absolute')
                    .style('background', 'rgba(0, 0, 0, 0.85)')
                    .style('color', 'white')
                    .style('padding', '8px 12px')
                    .style('border-radius', '8px')
                    .style('font-size', '12px')
                    .style('pointer-events', 'none')
                    .style('opacity', 0)
                    .style('z-index', 10000)
                    .style('white-space', 'nowrap')
                    .style('box-shadow', '0 4px 12px rgba(0,0,0,0.2)')
                    .style('transition', 'opacity 0.2s ease');
            }
            
            // Bind data to arcs
            const pieData = pie(data);
            
            // Add arcs (always fresh since we clear container)
            g.selectAll('path.arc')
                .data(pieData)
                .enter()
                .append('path')
                .attr('class', 'arc')
                .attr('fill', d => d.data.color)
                .attr('stroke', '#ffffff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('d', arcHover);
                    
                    const percent = ((d.data.count / total) * 100).toFixed(1);
                    tooltipEl
                        .html(`<strong>${d.data.label}</strong><br/>${d.data.count} (${percent}%)`)
                        .style('opacity', 1)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mousemove', function(event) {
                    tooltipEl
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('d', arc);
                    
                    tooltipEl.style('opacity', 0);
                })
                .transition()
                .duration(800)
                .ease(d3.easeCubicOut)
                .attrTween('d', arcTween);
            
            // Add center text
            const centerText = g.append('text')
                .attr('class', 'center-text chart-center-text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.1em')
                .style('opacity', 0);
            
            const centerLabel = g.append('text')
                .attr('class', 'center-label chart-center-label')
                .attr('text-anchor', 'middle')
                .attr('dy', '1.5em')
                .style('opacity', 0)
                .text('total');
            
            // Animate center number
            centerText
                .transition()
                .duration(600)
                .style('opacity', 1)
                .tween('text', function() {
                    const current = parseInt(this.textContent) || 0;
                    const i = d3.interpolateNumber(current, total);
                    return function(t) {
                        this.textContent = Math.round(i(t));
                    };
                });
            
            centerLabel
                .transition()
                .duration(600)
                .style('opacity', 1);
            
            // Update legend with staggered animation
            const existingLegendItems = legend.querySelectorAll('.legend-item');
            
            // Fade out existing legend items
            d3.select(`#${legendId}`).selectAll('.legend-item')
                .transition()
                .duration(200)
                .style('opacity', 0)
                .remove();
            
            // Add new legend items with stagger
            // Check if this is a side legend (for donut chart)
            const isSideLegend = legend.classList.contains('chart-side-legend');
            
            setTimeout(() => {
                legend.innerHTML = '';
                data.forEach((item, index) => {
                    const percent = ((item.count / total) * 100).toFixed(1);
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.title = `${item.label}: ${item.count} (${percent}%)`;
                    legendItem.style.opacity = '0';
                    legendItem.style.transform = isSideLegend ? 'translateX(-5px)' : 'translateY(5px)';
                    
                    if (isSideLegend) {
                        legendItem.innerHTML = `
                            <span class="legend-color" style="background: ${item.color}"></span>
                            <span class="legend-label">${item.label}</span>
                            <span class="legend-value">${item.count}</span>
                            <span class="legend-percent">(${percent}%)</span>
                        `;
                    } else {
                        legendItem.innerHTML = `
                            <span class="legend-color" style="background: ${item.color}"></span>
                            <span class="legend-label">${item.label}</span>
                            <span class="legend-percent">${percent}%</span>
                        `;
                    }
                    legend.appendChild(legendItem);
                    
                    // Staggered fade in
                    setTimeout(() => {
                        legendItem.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                        legendItem.style.opacity = '1';
                        legendItem.style.transform = isSideLegend ? 'translateX(0)' : 'translateY(0)';
                    }, 300 + (index * 50));
                });
            }, 200);
        }

        // Update stats
        function updateStats() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const activeCount = allConversations.filter(c => c.statuscode === 2).length;
            const waitingCount = allConversations.filter(c => c.statuscode === 3 || c.statuscode === 1).length;
            const wrapupCount = allConversations.filter(c => c.statuscode === 5).length;
            const closedTodayCount = allConversations.filter(c => {
                if (c.statuscode !== 4 && c.statuscode !== 6) return false;
                if (!c.closedon) return false;
                const closeDate = new Date(c.closedon);
                closeDate.setHours(0, 0, 0, 0);
                return closeDate.getTime() === today.getTime();
            }).length;
            
            document.getElementById('activeCount').textContent = activeCount;
            document.getElementById('waitingCount').textContent = waitingCount;
            document.getElementById('wrapupCount').textContent = wrapupCount;
            document.getElementById('closedCount').textContent = closedTodayCount;
            
            // Show filtered count if different from total, otherwise just total
            const totalEl = document.getElementById('totalCount');
            if (filteredConversations.length !== allConversations.length) {
                totalEl.textContent = `${filteredConversations.length} / ${allConversations.length}`;
                totalEl.title = `${filteredConversations.length} filtered of ${allConversations.length} total`;
            } else {
                totalEl.textContent = allConversations.length;
                totalEl.title = 'Total records';
            }
        }

        // Render conversations
        function renderConversations() {
            const tbody = document.getElementById('conversationsTable');
            
            // Get visible column count for colspan
            const visibleColumnCount = columnOrder.filter(colId => visibleColumns.has(colId)).length;
            
            if (filteredConversations.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="${visibleColumnCount}">
                            <div class="empty-state">
                                <div class="empty-state-icon"><img src="https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Chat%20Multiple/SVG/ic_fluent_chat_multiple_32_regular.svg" alt="Chat" width="48" height="48"></div>
                                <p>No conversations found</p>
                            </div>
                        </td>
                    </tr>
                `;
                updatePagination(0, 0, 0);
                updateSelectAllCheckbox();
                return;
            }
            
            // Pagination
            const totalRecords = filteredConversations.length;
            const totalPages = Math.ceil(totalRecords / pageSize);
            currentPage = Math.min(currentPage, totalPages);
            
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, totalRecords);
            const pageData = filteredConversations.slice(startIndex, endIndex);
            
            tbody.innerHTML = pageData.map(conv => {
                try {
                    const channel = channelMap[conv.channel] || { name: 'Unknown' };
                    const status = statusMap[conv.statuscode] || { label: 'Unknown', class: 'open' };
                    const createdDate = new Date(conv.createdon);
                    const initials = (conv.agentName || 'NA').split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                    const isSelected = selectedConversations.has(conv.id);
                    
                    // Build avatar content - use image only if entityimageid exists, otherwise show initials
                    // Note: Most D365 users don't have Dataverse entityimage - their photos come from Azure AD
                    let avatarContent;
                    if (conv.agentImageUrl && conv.agentId) {
                        // User has a Dataverse profile picture
                        avatarContent = `<img src="${conv.agentImageUrl}" alt="${escapeHtml(conv.agentName || '')}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;" onerror="this.style.display='none';this.nextElementSibling.style.display='flex';"/><span class="avatar-initials" style="display:none;width:100%;height:100%;align-items:center;justify-content:center;">${initials || '??'}</span>`;
                    } else {
                        // Show styled initials (most common case)
                        avatarContent = initials || '??';
                    }
                    
                    // Context object for rendering columns
                    const ctx = { conv, channel, status, createdDate, initials, isSelected, avatarContent };
                    
                    // Build row dynamically based on column order and visibility
                    const cells = columnOrder
                        .filter(colKey => visibleColumns.has(colKey))
                        .map(colKey => {
                            try {
                                const colDef = columnDefinitions[colKey];
                                if (!colDef) return '<td>-</td>';
                                return colDef.render(ctx);
                            } catch (cellError) {
                                console.warn(`Error rendering column ${colKey}:`, cellError);
                                return '<td><span class="text-muted">-</span></td>';
                            }
                        }).join('');
                    
                    return `<tr>${cells}</tr>`;
                } catch (rowError) {
                    console.warn('Error rendering conversation row:', rowError, conv);
                    return `<tr><td colspan="${visibleColumnCount}"><span class="text-muted">Error rendering row</span></td></tr>`;
                }
            }).join('');
            
            updatePagination(startIndex + 1, endIndex, totalRecords);
            updateSelectAllCheckbox();
            updateFilteredCountDisplay();
            
            // Update dashboard charts with filtered data
            updateDashboardCharts();
        }

        // Update pagination
        function updatePagination(start, end, total) {
            document.getElementById('showingStart').textContent = start;
            document.getElementById('showingEnd').textContent = end;
            document.getElementById('totalRecords').textContent = total;
            
            const totalPages = Math.ceil(total / pageSize);
            document.getElementById('prevBtn').disabled = currentPage <= 1;
            document.getElementById('nextBtn').disabled = currentPage >= totalPages;
        }
        
        // Update filtered count display
        function updateFilteredCountDisplay() {
            const countDisplay = document.getElementById('filteredCountDisplay');
            if (countDisplay) {
                countDisplay.textContent = filteredConversations.length;
            }
        }

        // Pagination controls
        function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                renderConversations();
            }
        }

        function nextPage() {
            const totalPages = Math.ceil(filteredConversations.length / pageSize);
            if (currentPage < totalPages) {
                currentPage++;
                renderConversations();
            }
        }

        // Change page size
        function changePageSize(newSize) {
            pageSize = parseInt(newSize, 10);
            currentPage = 1; // Reset to first page
            
            // Save to localStorage
            try {
                localStorage.setItem('advConv_pageSize', pageSize);
            } catch (e) {
                console.log('Could not save page size to localStorage');
            }
            
            renderConversations();
        }

        // Filter functions
        function setStatusFilter(status) {
            currentStatusFilter = status;
            currentPage = 1;
            
            // Reset stat card filter when using filter tabs
            currentStatCardFilter = 'all';
            document.querySelectorAll('.stat-card').forEach(card => card.classList.remove('active'));
            
            // Update tab UI
            document.querySelectorAll('.filter-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.filter === status);
            });
            
            loadConversations().then(() => {
                updateDashboardCharts();
                updateClearFiltersButton();
            });
        }

        // Track current status card filter
        let currentStatCardFilter = 'all';

        function filterByStatus(status, element) {
            currentStatCardFilter = status;
            
            // Update stat card visual states
            document.querySelectorAll('.stat-card').forEach(card => card.classList.remove('active'));
            if (element) {
                element.classList.add('active');
            }
            
            // Reset other filters first
            currentStatusFilter = 'all';
            document.querySelectorAll('.filter-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector('.filter-tab[data-filter="all"]').classList.add('active');
            
            // Apply the status filter on existing data (don't reload)
            if (status === 'all') {
                // Show all conversations
                filteredConversations = [...allConversations];
            } else if (status === 'active') {
                filteredConversations = allConversations.filter(c => c.statuscode === 2);
            } else if (status === 'waiting') {
                filteredConversations = allConversations.filter(c => c.statuscode === 3 || c.statuscode === 1);
            } else if (status === 'wrapup') {
                filteredConversations = allConversations.filter(c => c.statuscode === 5);
            } else if (status === 'closed') {
                // Filter for closed today - match exactly how updateStats does it
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                filteredConversations = allConversations.filter(c => {
                    if (c.statuscode !== 4 && c.statuscode !== 6) return false;
                    if (!c.closedon) return false;
                    const closeDate = new Date(c.closedon);
                    closeDate.setHours(0, 0, 0, 0);
                    return closeDate.getTime() === today.getTime();
                });
            }
            
            currentPage = 1;
            renderConversations();
            updateDashboardCharts();
            updateClearFiltersButton();
        }
        
        // Clear all filters and reset to default state
        function clearAllFilters() {
            // Reset status filter
            currentStatusFilter = 'all';
            currentStatCardFilter = 'all';
            
            // Reset filter tabs
            document.querySelectorAll('.filter-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector('.filter-tab[data-filter="all"]').classList.add('active');
            
            // Reset stat cards
            document.querySelectorAll('.stat-card').forEach(card => card.classList.remove('active'));
            
            // Reset channel filter (multi-select)
            selectedChannels.clear();
            document.getElementById('channelTriggerText').textContent = 'All Channels';
            document.querySelectorAll('#channelOptions .searchable-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Reset queue filter (multi-select)
            selectedQueues.clear();
            document.getElementById('queueTriggerText').textContent = 'All Queues';
            document.querySelectorAll('#queueOptions .searchable-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Reset agent filter (multi-select)
            selectedAgents.clear();
            document.getElementById('agentTriggerText').textContent = 'All Agents';
            document.querySelectorAll('#agentOptions .searchable-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Reset search
            document.getElementById('searchInput').value = '';
            
            // Reset date to default (last 30 days)
            selectPreset('month');
            
            // Reload data
            currentPage = 1;
            loadConversations().then(() => {
                updateDashboardCharts();
                updateClearFiltersButton();
            });
        }
        
        // Show/hide clear filters button based on active filters
        function updateClearFiltersButton() {
            const hasFilters = 
                currentStatCardFilter !== 'all' ||
                currentStatusFilter !== 'all' ||
                selectedChannels.size > 0 ||
                selectedQueues.size > 0 ||
                selectedAgents.size > 0 ||
                document.getElementById('searchInput').value !== '';
            
            const btn = document.getElementById('clearFiltersBtn');
            if (btn) {
                btn.style.display = hasFilters ? 'flex' : 'none';
            }
        }

        function applyFilters() {
            currentPage = 1;
            // Reset stat card filter when other filters are used
            currentStatCardFilter = 'all';
            document.querySelectorAll('.stat-card').forEach(card => card.classList.remove('active'));
            loadConversations().then(() => {
                updateDashboardCharts();
                updateClearFiltersButton();
            });
        }

        // Check if string looks like a GUID
        function isGuid(str) {
            const guidPattern = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;
            return guidPattern.test(str.trim());
        }

        // Search directly in D365 by conversation ID
        async function searchByConversationId(conversationId) {
            const xrm = xrmGlobal || getXrm();
            if (!xrm) return null;

            try {
                // Clean the ID - remove dashes if present for consistent format
                const cleanId = conversationId.trim().toLowerCase();
                
                // Query D365 directly for this specific conversation
                const query = `?$select=msdyn_ocliveworkitemid,msdyn_channel,statuscode,statecode,createdon,msdyn_closedon,msdyn_title,_msdyn_activeagentid_value,_msdyn_cdsqueueid_value,_msdyn_liveworkstreamid_value,_msdyn_customer_value&$filter=msdyn_ocliveworkitemid eq '${cleanId}'`;
                
                const response = await xrm.WebApi.retrieveMultipleRecords("msdyn_ocliveworkitem", query);
                
                if (response.entities && response.entities.length > 0) {
                    const clientUrl = xrm.Utility.getGlobalContext().getClientUrl();
                    
                    return response.entities.map(conv => {
                        const agentId = conv._msdyn_activeagentid_value;
                        // Use the image URL from agentImageMap - already a full URL
                        const agentImageUrl = agentId && agentImageMap[agentId] ? 
                            agentImageMap[agentId] : 
                            null;
                        
                        return {
                            id: conv.msdyn_ocliveworkitemid,
                            workitemid: conv.msdyn_ocliveworkitemid ? conv.msdyn_ocliveworkitemid.substring(0, 8).toUpperCase() : 'N/A',
                            title: conv.msdyn_title || 'Conversation',
                            channel: conv.msdyn_channel !== null && conv.msdyn_channel !== undefined ? String(conv.msdyn_channel) : null,
                            statuscode: conv.statuscode,
                            statecode: conv.statecode,
                            createdon: conv.createdon,
                            closedon: conv.msdyn_closedon,
                            workstreamId: conv._msdyn_liveworkstreamid_value,
                            workstreamName: conv['_msdyn_liveworkstreamid_value@OData.Community.Display.V1.FormattedValue'] || 'N/A',
                            agentId: agentId,
                            agentImageUrl: agentImageUrl,
                            agentName: conv['_msdyn_activeagentid_value@OData.Community.Display.V1.FormattedValue'] || 'Unassigned',
                            queueId: conv._msdyn_cdsqueueid_value,
                            queueName: conv['_msdyn_cdsqueueid_value@OData.Community.Display.V1.FormattedValue'] || 'N/A',
                            customerId: conv._msdyn_customer_value,
                            customerName: conv['_msdyn_customer_value@OData.Community.Display.V1.FormattedValue'] || 'Unknown Customer'
                        };
                    });
                }
                return [];
            } catch (error) {
                console.error('Error searching by conversation ID:', error);
                return null;
            }
        }

        // Search with debounce
        function debounceSearch() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                const searchTerm = document.getElementById('searchInput').value.trim();
                
                // Update clear filters button
                updateClearFiltersButton();
                
                // If it looks like a GUID, search D365 directly
                if (isGuid(searchTerm)) {
                    console.log('GUID detected, searching D365 directly for:', searchTerm);
                    showLoading();
                    
                    const results = await searchByConversationId(searchTerm);
                    
                    if (results && results.length > 0) {
                        filteredConversations = results;
                        currentPage = 1;
                        updateStats();
                        renderConversations();
                        updateDashboardCharts();
                        return;
                    } else {
                        // Not found - show empty state
                        filteredConversations = [];
                        currentPage = 1;
                        updateStats();
                        renderConversations();
                        updateDashboardCharts();
                        return;
                    }
                }
                
                // Otherwise, do local filtering
                currentPage = 1;
                applySearchFilter();
                updateStats();
                renderConversations();
                updateDashboardCharts();
            }, 300);
        }

        // Sort
        function sortBy(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'desc';
            }
            
            // Save sort preference to localStorage
            saveSortPreference();
            
            sortConversations();
            renderConversations();
            
            // Update UI
            document.querySelectorAll('th.sortable').forEach(th => th.classList.remove('sorted'));
        }

        // Open conversation
        function openConversation(conversationId) {
            const xrm = xrmGlobal || getXrm();
            if (xrm && xrm.Navigation) {
                xrm.Navigation.openForm({
                    entityName: 'msdyn_ocliveworkitem',
                    entityId: conversationId
                });
            }
        }

        // Helper functions
        function showLoading() {
            document.getElementById('conversationsTable').innerHTML = `
                <tr>
                    <td colspan="9">
                        <div class="loading">
                            <div class="spinner"></div>
                            <p>Loading conversations...</p>
                        </div>
                    </td>
                </tr>
            `;
        }

        function showError() {
            document.getElementById('conversationsTable').innerHTML = `
                <tr>
                    <td colspan="9">
                        <div class="empty-state">
                            <div class="empty-state-icon"></div>
                            <p>This page must be run within Dynamics 365 Customer Service</p>
                        </div>
                    </td>
                </tr>
            `;
            
            document.getElementById('activeCount').textContent = '0';
            document.getElementById('waitingCount').textContent = '0';
            document.getElementById('wrapupCount').textContent = '0';
            document.getElementById('closedCount').textContent = '0';
            document.getElementById('totalCount').textContent = '0';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==========================================
        // TRANSCRIPT DOWNLOAD FUNCTIONALITY
        // ==========================================
        
        // Toggle individual conversation selection
        function toggleConversationSelection(conversationId, isChecked) {
            if (isChecked) {
                selectedConversations.add(conversationId);
            } else {
                selectedConversations.delete(conversationId);
            }
            updateDownloadButton();
            updateSelectAllCheckbox();
        }
        
        // Toggle select all for ALL filtered conversations (across all pages)
        function toggleSelectAll(event) {
            event.stopPropagation();
            const isChecked = event.target.checked;
            
            // Select/deselect ALL filtered conversations, not just current page
            filteredConversations.forEach(conv => {
                if (isChecked) {
                    selectedConversations.add(conv.id);
                } else {
                    selectedConversations.delete(conv.id);
                }
            });
            
            // Update checkboxes in the table (current page)
            document.querySelectorAll('.conv-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            
            updateDownloadButton();
        }
        
        // Update select all checkbox state
        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (!selectAllCheckbox) return;
            
            if (filteredConversations.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                return;
            }
            
            // Check how many of ALL filtered conversations are selected
            const selectedCount = filteredConversations.filter(conv => selectedConversations.has(conv.id)).length;
            
            if (selectedCount === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (selectedCount === filteredConversations.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }
        
        // Update download button state
        function updateDownloadButton() {
            const downloadBtn = document.getElementById('downloadTranscriptsBtn');
            const downloadBadge = document.getElementById('selectedCountBadge');
            const closeBtn = document.getElementById('closeConversationsBtn');
            const closeBadge = document.getElementById('closeCountBadge');
            const assignBtn = document.getElementById('assignAgentBtn');
            const assignBadge = document.getElementById('assignCountBadge');
            const count = selectedConversations.size;
            
            downloadBadge.textContent = count;
            downloadBtn.disabled = count === 0;
            
            closeBadge.textContent = count;
            closeBtn.disabled = count === 0;
            
            assignBadge.textContent = count;
            assignBtn.disabled = count === 0;
        }
        
        // Open download modal
        function openDownloadModal() {
            if (selectedConversations.size === 0) return;
            
            const modal = document.getElementById('downloadModal');
            const title = document.getElementById('downloadModalTitle');
            const subtitle = document.getElementById('downloadModalSubtitle');
            const progressBar = document.getElementById('downloadProgressBar');
            const progressText = document.getElementById('downloadProgressText');
            const log = document.getElementById('downloadLog');
            const startBtn = document.getElementById('startDownloadBtn');
            const formatSection = document.getElementById('formatSelection');
            const progressSection = document.getElementById('downloadProgressSection');
            
            title.textContent = `Download ${selectedConversations.size} Transcript${selectedConversations.size > 1 ? 's' : ''}`;
            subtitle.textContent = 'Select format and download conversation transcripts';
            progressBar.style.width = '0%';
            progressText.textContent = 'Ready to download';
            log.innerHTML = '';
            startBtn.disabled = false;
            startBtn.textContent = 'Start Download';
            isDownloading = false;
            
            // Reset to format selection view
            formatSection.style.display = 'block';
            progressSection.style.display = 'none';
            
            // Reset format selection to JSON
            const jsonRadio = document.querySelector('input[name="downloadFormat"][value="json"]');
            if (jsonRadio) jsonRadio.checked = true;
            
            modal.classList.add('open');
        }
        
        // Close download modal
        function closeDownloadModal() {
            if (isDownloading) {
                if (!confirm('Download in progress. Are you sure you want to cancel?')) {
                    return;
                }
            }
            isDownloading = false;
            document.getElementById('downloadModal').classList.remove('open');
        }
        
        // Add log entry
        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('downloadLog');
            const entry = document.createElement('div');
            entry.className = `download-log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }
        
        // Update progress
        function updateProgress(current, total, message) {
            const progressBar = document.getElementById('downloadProgressBar');
            const progressText = document.getElementById('downloadProgressText');
            const percentage = Math.round((current / total) * 100);
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = message || `Processing ${current} of ${total} (${percentage}%)`;
        }
        
        // Fetch transcript for a conversation - tries multiple approaches
        async function fetchTranscript(conversationId) {
            const xrm = xrmGlobal || getXrm();
            if (!xrm) throw new Error('D365 API not available');
            
            try {
                // APPROACH 1: Get the msdyn_transcript record linked to this conversation
                addLogEntry(`   Looking for transcript record...`, 'info');
                const transcriptQuery = `?$select=msdyn_transcriptid,msdyn_name,createdon&$filter=_msdyn_liveworkitemidid_value eq '${conversationId}'`;
                const transcriptResponse = await xrm.WebApi.retrieveMultipleRecords("msdyn_transcript", transcriptQuery);
                
                if (transcriptResponse.entities && transcriptResponse.entities.length > 0) {
                    const transcriptRecord = transcriptResponse.entities[0];
                    const transcriptId = transcriptRecord.msdyn_transcriptid;
                    addLogEntry(`   Found transcript record: ${transcriptId.substring(0, 8)}...`, 'info');
                    
                    // APPROACH 2: Get annotation linked to the msdyn_transcript record
                    addLogEntry(`   Fetching annotation content for transcript...`, 'info');
                    const annotationQuery = `?$select=annotationid,documentbody,filename,notetext,subject,createdon&$filter=_objectid_value eq '${transcriptId}'&$orderby=createdon desc`;
                    const annotationResponse = await xrm.WebApi.retrieveMultipleRecords("annotation", annotationQuery);
                    
                    if (annotationResponse.entities && annotationResponse.entities.length > 0) {
                        addLogEntry(`   Found ${annotationResponse.entities.length} annotation(s) on transcript`, 'info');
                        const result = parseAnnotations(annotationResponse.entities);
                        if (result && result.length > 0) return result;
                    }
                }
                
                // APPROACH 3: Try to get annotation directly linked to conversation (msdyn_ocliveworkitem)
                addLogEntry(`   Trying direct annotation on conversation...`, 'info');
                const directAnnotationQuery = `?$select=annotationid,documentbody,filename,notetext,subject,createdon,objecttypecode&$filter=_objectid_value eq '${conversationId}'&$orderby=createdon desc`;
                const directAnnotationResponse = await xrm.WebApi.retrieveMultipleRecords("annotation", directAnnotationQuery);
                
                if (directAnnotationResponse.entities && directAnnotationResponse.entities.length > 0) {
                    addLogEntry(`   Found ${directAnnotationResponse.entities.length} direct annotation(s)`, 'info');
                    const result = parseAnnotations(directAnnotationResponse.entities);
                    if (result && result.length > 0) return result;
                }
                
                // APPROACH 4: Try msdyn_conversationmessageblock - message blocks for conversation
                addLogEntry(`   Trying conversation message blocks...`, 'info');
                try {
                    const msgBlockQuery = `?$select=msdyn_conversationmessageblockid,msdyn_content,msdyn_sentreceivedstatus,createdon&$filter=_msdyn_ocliveworkitemid_value eq '${conversationId}'&$orderby=createdon asc`;
                    const msgBlockResponse = await xrm.WebApi.retrieveMultipleRecords("msdyn_conversationmessageblock", msgBlockQuery);
                    
                    if (msgBlockResponse.entities && msgBlockResponse.entities.length > 0) {
                        addLogEntry(`   Found ${msgBlockResponse.entities.length} message block(s)`, 'info');
                        const messages = msgBlockResponse.entities.map(block => ({
                            content: block.msdyn_content,
                            createdDateTime: block.createdon,
                            from: { user: { displayName: block.msdyn_sentreceivedstatus === 0 ? 'Agent' : 'Customer' } }
                        }));
                        if (messages.length > 0) return messages;
                    }
                } catch (msgBlockError) {
                    addLogEntry(`   Message blocks not accessible`, 'info');
                }
                
                // APPROACH 5: Try msdyn_conversationaction - get conversation actions/messages
                addLogEntry(`   Trying conversation actions...`, 'info');
                try {
                    const actionQuery = `?$select=msdyn_conversationactionid,msdyn_name,msdyn_messagebody,createdon,msdyn_conversationactiontype&$filter=_msdyn_liveworkitemid_value eq '${conversationId}'&$orderby=createdon asc`;
                    const actionResponse = await xrm.WebApi.retrieveMultipleRecords("msdyn_conversationaction", actionQuery);
                    
                    if (actionResponse.entities && actionResponse.entities.length > 0) {
                        addLogEntry(`   Found ${actionResponse.entities.length} conversation action(s)`, 'info');
                        const messages = actionResponse.entities
                            .filter(action => action.msdyn_messagebody)
                            .map(action => ({
                                content: action.msdyn_messagebody,
                                createdDateTime: action.createdon,
                                from: { user: { displayName: action.msdyn_name || 'Participant' } }
                            }));
                        if (messages.length > 0) return messages;
                    }
                } catch (actionError) {
                    addLogEntry(`   Conversation actions not accessible`, 'info');
                }
                
                // APPROACH 6: Try broader annotation search with objecttypecode = 'msdyn_transcript'
                if (transcriptResponse.entities && transcriptResponse.entities.length > 0) {
                    addLogEntry(`   Trying broader annotation search...`, 'info');
                    try {
                        const transcriptId = transcriptResponse.entities[0].msdyn_transcriptid;
                        const broadQuery = `?$select=annotationid,documentbody,filename,notetext,subject,createdon,_objectid_value&$filter=objecttypecode eq 'msdyn_transcript'&$orderby=createdon desc&$top=100`;
                        const broadResponse = await xrm.WebApi.retrieveMultipleRecords("annotation", broadQuery);
                        
                        if (broadResponse.entities && broadResponse.entities.length > 0) {
                            addLogEntry(`   Found ${broadResponse.entities.length} transcript annotations total`, 'info');
                            const matching = broadResponse.entities.filter(a => a._objectid_value === transcriptId);
                            if (matching.length > 0) {
                                addLogEntry(`   Found ${matching.length} matching annotation(s)`, 'info');
                                const result = parseAnnotations(matching);
                                if (result && result.length > 0) return result;
                            }
                        }
                    } catch (broadError) {
                        addLogEntry(`   Broad search failed: ${broadError.message}`, 'error');
                    }
                }
                
                addLogEntry(`   No transcript content found after all approaches`, 'info');
                return null;
                
            } catch (error) {
                console.error('Error fetching transcript:', error);
                addLogEntry(`   Error: ${error.message}`, 'error');
                throw error;
            }
        }
        
        // Parse annotation records and extract transcript content
        function parseAnnotations(annotations) {
            const allMessages = [];
            
            for (const annotation of annotations) {
                if (annotation.documentbody) {
                    try {
                        // Decode base64 content
                        const decodedContent = atob(annotation.documentbody);
                        
                        // Try to parse as JSON
                        try {
                            const jsonContent = JSON.parse(decodedContent);
                            const messages = extractMessagesFromJson(jsonContent);
                            allMessages.push(...messages);
                        } catch (parseError) {
                            // Not JSON, treat as raw text
                            allMessages.push({ rawText: decodedContent, source: 'annotation' });
                        }
                    } catch (decodeError) {
                        console.error('Error decoding annotation:', decodeError);
                    }
                }
                
                // Also check notetext field which might contain transcript
                if (annotation.notetext && annotation.notetext.length > 50) {
                    try {
                        const noteJson = JSON.parse(annotation.notetext);
                        const messages = extractMessagesFromJson(noteJson);
                        allMessages.push(...messages);
                    } catch (e) {
                        // Not JSON, might be plain text transcript
                        if (!annotation.documentbody) {
                            allMessages.push({ rawText: annotation.notetext, source: 'notetext' });
                        }
                    }
                }
            }
            
            if (allMessages.length > 0) {
                // Sort by timestamp if available
                allMessages.sort((a, b) => {
                    const timeA = a.createdDateTime || a.created || a.timestamp || '';
                    const timeB = b.createdDateTime || b.created || b.timestamp || '';
                    return timeA.localeCompare(timeB);
                });
                return allMessages;
            }
            
            return null;
        }
        
        // Extract messages from various JSON structures
        function extractMessagesFromJson(jsonContent) {
            const messages = [];
            
            // Handle array of items
            if (Array.isArray(jsonContent)) {
                for (const item of jsonContent) {
                    // Check if item has a Content field with nested JSON (D365 transcript format)
                    if (item.Content && typeof item.Content === 'string') {
                        try {
                            const innerContent = JSON.parse(item.Content);
                            if (Array.isArray(innerContent)) {
                                messages.push(...innerContent);
                            } else {
                                messages.push(innerContent);
                            }
                        } catch (e) {
                            // Content is not JSON, use as-is
                            messages.push({ content: item.Content, source: 'Content field' });
                        }
                    } else {
                        // Direct message object
                        messages.push(item);
                    }
                }
            } else if (jsonContent.messages && Array.isArray(jsonContent.messages)) {
                messages.push(...jsonContent.messages);
            } else if (jsonContent.replayList && Array.isArray(jsonContent.replayList)) {
                messages.push(...jsonContent.replayList);
            } else if (jsonContent.Content && typeof jsonContent.Content === 'string') {
                // Single item with Content field
                try {
                    const innerContent = JSON.parse(jsonContent.Content);
                    if (Array.isArray(innerContent)) {
                        messages.push(...innerContent);
                    } else {
                        messages.push(innerContent);
                    }
                } catch (e) {
                    messages.push({ content: jsonContent.Content, source: 'Content field' });
                }
            } else {
                // Single object
                messages.push(jsonContent);
            }
            
            return messages;
        }
        
        // Format transcript for human readability
        function formatTranscript(conversationData, transcriptJson) {
            const lines = [];
            const channel = channelMap[conversationData.channel] || { name: 'Unknown', icon: '' };
            const status = statusMap[conversationData.statuscode] || { label: 'Unknown' };
            
            // Header
            lines.push(''.repeat(80));
            lines.push('CONVERSATION TRANSCRIPT');
            lines.push(''.repeat(80));
            lines.push('');
            lines.push(`Conversation ID: ${conversationData.id}`);
            lines.push(`Short ID: ${conversationData.workitemid}`);
            lines.push(`Title: ${conversationData.title}`);
            lines.push(`Customer: ${conversationData.customerName}`);
            lines.push(`Agent: ${conversationData.agentName}`);
            lines.push(`Queue: ${conversationData.queueName}`);
            lines.push(`Channel: ${channel.name}`);
            lines.push(`Status: ${status.label}`);
            lines.push(`Started: ${new Date(conversationData.createdon).toLocaleString()}`);
            if (conversationData.closedon) {
                lines.push(`Closed: ${new Date(conversationData.closedon).toLocaleString()}`);
            }
            lines.push(`Duration: ${formatDuration(conversationData)}`);
            lines.push('');
            lines.push(''.repeat(80));
            lines.push('MESSAGES');
            lines.push(''.repeat(80));
            lines.push('');
            
            if (!transcriptJson) {
                lines.push('[No transcript available for this conversation]');
            } else if (Array.isArray(transcriptJson)) {
                // Parse the transcript JSON array
                let messageCount = 0;
                
                // Deduplicate messages - voice transcripts often have duplicate entries
                // with same content and timestamp but different senders (agent echo)
                const seenMessages = new Map(); // Use Map to store best version
                
                transcriptJson.forEach(msg => {
                    // Create a key based on timestamp + content to detect duplicates
                    const timestamp = msg.createdDateTime || msg.created || msg.timestamp || msg.time || '';
                    const content = msg.content || msg.text || msg.message || msg.body || '';
                    
                    // Normalize content for comparison (trim, lowercase)
                    const normalizedContent = content.trim().toLowerCase();
                    const dedupeKey = `${timestamp}|${normalizedContent}`;
                    
                    if (!normalizedContent) {
                        // No content, keep it (might be attachment or system)
                        seenMessages.set(Math.random().toString(), msg);
                        return;
                    }
                    
                    // Check message properties to determine priority
                    const tags = msg.tags || '';
                    const isPrivate = (typeof tags === 'string' && tags.includes('private')) || msg.visibility === 'private';
                    
                    // If we haven't seen this message, store it
                    if (!seenMessages.has(dedupeKey)) {
                        seenMessages.set(dedupeKey, { msg, isPrivate });
                    } else {
                        // We've seen this message - prefer non-private version over private
                        const existing = seenMessages.get(dedupeKey);
                        if (existing.isPrivate && !isPrivate) {
                            // Replace private message with public one (actual speaker)
                            seenMessages.set(dedupeKey, { msg, isPrivate });
                        }
                    }
                });
                
                // Extract just the messages, preserving order
                const deduplicatedMessages = Array.from(seenMessages.values()).map(v => v.msg || v);
                
                // Sort by timestamp
                deduplicatedMessages.sort((a, b) => {
                    const timeA = a.createdDateTime || a.created || a.timestamp || a.time || '';
                    const timeB = b.createdDateTime || b.created || b.timestamp || b.time || '';
                    return timeA.localeCompare(timeB);
                });
                
                deduplicatedMessages.forEach(msg => {
                    // Handle raw text items
                    if (msg.rawText) {
                        lines.push(msg.rawText);
                        lines.push('');
                        messageCount++;
                        return;
                    }
                    
                    // Skip control messages
                    if (msg.isControlMessage) {
                        return;
                    }
                    
                    // Get timestamp from various possible fields
                    const timestamp = msg.createdDateTime || msg.created || msg.timestamp || msg.time || '';
                    const formattedTime = timestamp ? new Date(timestamp).toLocaleString() : '';
                    
                    // Determine sender from tags first (more reliable)
                    const tags = msg.tags || '';
                    const isFromCustomer = typeof tags === 'string' && tags.includes('FromCustomer');
                    const isFromAgent = typeof tags === 'string' && (tags.includes('FromAgent') || tags.includes('public'));
                    
                    // Get sender from various possible structures
                    let sender = 'Unknown';
                    if (isFromCustomer) {
                        sender = conversationData.customerName || 'Customer';
                    } else if (isFromAgent) {
                        sender = conversationData.agentName || 'Agent';
                    } else if (msg.from) {
                        if (typeof msg.from === 'string') {
                            sender = msg.from;
                        } else if (msg.from.user && msg.from.user.displayName) {
                            sender = msg.from.user.displayName;
                        } else if (msg.from.application && msg.from.application.displayName) {
                            const displayName = msg.from.application.displayName;
                            // Replace generic "Customer" with actual name
                            if (displayName === 'Customer' || displayName === 'customer') {
                                sender = conversationData.customerName || 'Customer';
                            } else {
                                sender = displayName;
                            }
                        } else if (msg.from.name) {
                            sender = msg.from.name;
                        } else if (msg.from.displayName) {
                            sender = msg.from.displayName;
                        }
                    } else if (msg.sender) {
                        sender = typeof msg.sender === 'string' ? msg.sender : (msg.sender.name || msg.sender.displayName || 'Unknown');
                    } else if (msg.author) {
                        sender = typeof msg.author === 'string' ? msg.author : (msg.author.name || msg.author.displayName || 'Unknown');
                    } else if (msg.displayName) {
                        sender = msg.displayName;
                    } else if (msg.name) {
                        sender = msg.name;
                    }
                    
                    // Get message content from various possible fields
                    const content = msg.content || msg.text || msg.message || msg.body || '';
                    
                    if (!content && !msg.attachments) {
                        return; // Skip empty messages
                    }
                    
                    // Check message type
                    const isSystem = (typeof tags === 'string' && tags.includes('system')) || msg.messageType === 'system' || msg.type === 'system';
                    const isPrivate = (typeof tags === 'string' && tags.includes('private')) || msg.visibility === 'private';
                    
                    if (isSystem) {
                        lines.push(`[${formattedTime}]  SYSTEM: ${content}`);
                    } else if (msg.attachments && msg.attachments.length > 0) {
                        msg.attachments.forEach(att => {
                            lines.push(`[${formattedTime}]  ${sender}: [Attachment: ${att.name || att.filename || 'File'}]`);
                        });
                    } else if (content) {
                        const prefix = isPrivate ? ' ' : '';
                        lines.push(`[${formattedTime}] ${prefix}${sender}: ${content}`);
                    }
                    lines.push('');
                    messageCount++;
                });
                
                if (messageCount === 0) {
                    lines.push('[Transcript data found but no displayable messages]');
                    lines.push('');
                    lines.push('Raw data structure for debugging:');
                    lines.push(JSON.stringify(transcriptJson.slice(0, 3), null, 2));
                }
            } else if (transcriptJson.rawText) {
                lines.push(transcriptJson.rawText);
            } else if (typeof transcriptJson === 'object') {
                // Try to extract messages from various object structures
                const possibleArrays = ['messages', 'replayList', 'items', 'data', 'transcript', 'chatMessages'];
                let found = false;
                
                for (const key of possibleArrays) {
                    if (transcriptJson[key] && Array.isArray(transcriptJson[key])) {
                        lines.push(`[Found messages in '${key}' field]`);
                        lines.push('');
                        // Recursively format
                        const formatted = formatTranscript(conversationData, transcriptJson[key]);
                        // Extract just the messages part
                        const msgStart = formatted.indexOf('MESSAGES\n') + 9;
                        const msgEnd = formatted.lastIndexOf(''.repeat(80));
                        if (msgStart > 9 && msgEnd > msgStart) {
                            lines.push(formatted.substring(msgStart, msgEnd).trim());
                        }
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    lines.push('[Unknown transcript format]');
                    lines.push('');
                    lines.push('Raw data for debugging:');
                    lines.push(JSON.stringify(transcriptJson, null, 2).substring(0, 2000));
                }
            }
            
            lines.push('');
            lines.push(''.repeat(80));
            lines.push(`End of Transcript - Generated on ${new Date().toLocaleString()}`);
            lines.push(''.repeat(80));
            
            return lines.join('\n');
        }
        
        // Debug function to show raw D365 data for the first selected conversation
        async function debugTranscriptData() {
            if (selectedConversations.size === 0) {
                addLogEntry('No conversations selected to debug', 'error');
                return;
            }
            
            const conversationId = Array.from(selectedConversations)[0];
            const xrm = xrmGlobal || getXrm();
            
            if (!xrm) {
                addLogEntry('D365 API not available', 'error');
                return;
            }
            
            addLogEntry(`=== DEBUG MODE for conversation ${conversationId.substring(0, 8)}... ===`, 'info');
            
            try {
                // 1. Check msdyn_transcript records
                addLogEntry('1. Querying msdyn_transcript...', 'info');
                const transcriptQuery = `?$select=msdyn_transcriptid,msdyn_name,createdon&$filter=_msdyn_liveworkitemidid_value eq '${conversationId}'`;
                const transcriptResult = await xrm.WebApi.retrieveMultipleRecords("msdyn_transcript", transcriptQuery);
                addLogEntry(`   Found ${transcriptResult.entities.length} transcript record(s)`, 'info');
                
                if (transcriptResult.entities.length > 0) {
                    const tr = transcriptResult.entities[0];
                    addLogEntry(`   ID: ${tr.msdyn_transcriptid}`, 'info');
                    addLogEntry(`   Name: ${tr.msdyn_name || '(none)'}`, 'info');
                    
                    // 2. Check annotations for this transcript
                    addLogEntry('2. Querying annotations for transcript...', 'info');
                    const annotQuery = `?$select=annotationid,documentbody,notetext,subject,filename,createdon&$filter=_objectid_value eq '${tr.msdyn_transcriptid}'`;
                    const annotResult = await xrm.WebApi.retrieveMultipleRecords("annotation", annotQuery);
                    addLogEntry(`   Found ${annotResult.entities.length} annotation(s)`, 'info');
                    
                    annotResult.entities.forEach((ann, i) => {
                        addLogEntry(`   [${i}] Subject: ${ann.subject || '(none)'}`, 'info');
                        addLogEntry(`   [${i}] Filename: ${ann.filename || '(none)'}`, 'info');
                        addLogEntry(`   [${i}] DocumentBody: ${ann.documentbody ? ann.documentbody.substring(0, 50) + '...' : '(none)'}`, 'info');
                        addLogEntry(`   [${i}] NoteText: ${ann.notetext ? ann.notetext.substring(0, 50) + '...' : '(none)'}`, 'info');
                        
                        if (ann.documentbody) {
                            try {
                                const decoded = atob(ann.documentbody);
                                addLogEntry(`   [${i}] Decoded (first 200 chars): ${decoded.substring(0, 200)}`, 'info');
                            } catch (e) {
                                addLogEntry(`   [${i}] Decode error: ${e.message}`, 'error');
                            }
                        }
                    });
                }
                
                // 3. Check direct annotations on conversation
                addLogEntry('3. Querying annotations for conversation directly...', 'info');
                const directAnnotQuery = `?$select=annotationid,documentbody,notetext,subject,filename,objecttypecode,createdon&$filter=_objectid_value eq '${conversationId}'`;
                const directAnnotResult = await xrm.WebApi.retrieveMultipleRecords("annotation", directAnnotQuery);
                addLogEntry(`   Found ${directAnnotResult.entities.length} direct annotation(s)`, 'info');
                
                directAnnotResult.entities.forEach((ann, i) => {
                    addLogEntry(`   [${i}] TypeCode: ${ann.objecttypecode}`, 'info');
                    addLogEntry(`   [${i}] Subject: ${ann.subject || '(none)'}`, 'info');
                    addLogEntry(`   [${i}] DocumentBody: ${ann.documentbody ? 'YES (' + ann.documentbody.length + ' chars)' : 'NO'}`, 'info');
                });
                
                // 4. Check for message blocks
                addLogEntry('4. Querying msdyn_conversationmessageblock...', 'info');
                try {
                    const msgQuery = `?$select=msdyn_conversationmessageblockid,msdyn_content,createdon&$filter=_msdyn_ocliveworkitemid_value eq '${conversationId}'&$top=5`;
                    const msgResult = await xrm.WebApi.retrieveMultipleRecords("msdyn_conversationmessageblock", msgQuery);
                    addLogEntry(`   Found ${msgResult.entities.length} message block(s)`, 'info');
                    msgResult.entities.forEach((msg, i) => {
                        addLogEntry(`   [${i}] Content: ${msg.msdyn_content ? msg.msdyn_content.substring(0, 50) + '...' : '(none)'}`, 'info');
                    });
                } catch (e) {
                    addLogEntry(`   Entity not accessible: ${e.message}`, 'info');
                }
                
                // 5. Check conversation actions
                addLogEntry('5. Querying msdyn_conversationaction...', 'info');
                try {
                    const actQuery = `?$select=msdyn_conversationactionid,msdyn_messagebody,createdon&$filter=_msdyn_liveworkitemid_value eq '${conversationId}'&$top=5`;
                    const actResult = await xrm.WebApi.retrieveMultipleRecords("msdyn_conversationaction", actQuery);
                    addLogEntry(`   Found ${actResult.entities.length} conversation action(s)`, 'info');
                    actResult.entities.forEach((act, i) => {
                        addLogEntry(`   [${i}] MessageBody: ${act.msdyn_messagebody ? act.msdyn_messagebody.substring(0, 50) + '...' : '(none)'}`, 'info');
                    });
                } catch (e) {
                    addLogEntry(`   Entity not accessible: ${e.message}`, 'info');
                }
                
                addLogEntry('=== DEBUG COMPLETE ===', 'success');
                
            } catch (error) {
                addLogEntry(`Debug error: ${error.message}`, 'error');
            }
        }
        
        // Start transcript download
        async function startTranscriptDownload() {
            if (isDownloading || selectedConversations.size === 0) return;
            
            // Get selected format
            const formatRadio = document.querySelector('input[name="downloadFormat"]:checked');
            const selectedFormat = formatRadio ? formatRadio.value : 'json';
            
            // Switch to progress view
            document.getElementById('formatSelection').style.display = 'none';
            document.getElementById('downloadProgressSection').style.display = 'block';
            
            isDownloading = true;
            const startBtn = document.getElementById('startDownloadBtn');
            startBtn.disabled = true;
            startBtn.textContent = 'Downloading...';
            
            const selectedIds = Array.from(selectedConversations);
            const total = selectedIds.length;
            let processed = 0;
            let successful = 0;
            let failed = 0;
            const allTranscripts = [];
            
            addLogEntry(`Starting download of ${total} transcript${total > 1 ? 's' : ''} in ${selectedFormat} format...`, 'info');
            
            for (const conversationId of selectedIds) {
                if (!isDownloading) {
                    addLogEntry('Download cancelled by user', 'error');
                    break;
                }
                
                processed++;
                updateProgress(processed, total);
                
                // Find conversation data
                const convData = allConversations.find(c => c.id === conversationId) || 
                                filteredConversations.find(c => c.id === conversationId);
                
                if (!convData) {
                    addLogEntry(` Conversation ${conversationId.substring(0, 8)}... not found in data`, 'error');
                    failed++;
                    continue;
                }
                
                try {
                    addLogEntry(`Fetching transcript for ${convData.workitemid} (${convData.customerName})...`, 'info');
                    
                    const transcriptJson = await fetchTranscript(conversationId);
                    
                    // Log what we got back
                    if (transcriptJson) {
                        const msgCount = Array.isArray(transcriptJson) ? transcriptJson.length : 
                                        (transcriptJson.messages ? transcriptJson.messages.length : 
                                        (transcriptJson.replayList ? transcriptJson.replayList.length : 1));
                        addLogEntry(`   Retrieved ${msgCount} message(s)`, 'info');
                    }
                    
                    const formattedTranscript = formatTranscript(convData, transcriptJson);
                    
                    allTranscripts.push({
                        conversationId: conversationId,
                        workitemid: convData.workitemid,
                        customerName: convData.customerName,
                        content: formattedTranscript,
                        hasTranscript: !!transcriptJson,
                        rawTranscript: transcriptJson // Store raw data for JSON export
                    });
                    
                    if (transcriptJson) {
                        addLogEntry(` ${convData.workitemid}: Transcript retrieved successfully`, 'success');
                    } else {
                        addLogEntry(` ${convData.workitemid}: No transcript available (metadata only)`, 'info');
                    }
                    successful++;
                    
                } catch (error) {
                    addLogEntry(` ${convData.workitemid}: Error - ${error.message}`, 'error');
                    failed++;
                    
                    // Still include the conversation with error note
                    allTranscripts.push({
                        conversationId: conversationId,
                        workitemid: convData.workitemid,
                        customerName: convData.customerName,
                        content: formatTranscript(convData, null) + `\n\n[Error fetching transcript: ${error.message}]`,
                        hasTranscript: false,
                        rawTranscript: null,
                        error: error.message
                    });
                }
                
                // Small delay to avoid overwhelming the API
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            updateProgress(total, total, 'Download complete!');
            addLogEntry(`Completed: ${successful} successful, ${failed} failed`, successful === total ? 'success' : 'info');
            
            // Generate and download the file based on selected format
            if (allTranscripts.length > 0) {
                addLogEntry(`Generating ${selectedFormat} file...`, 'info');
                await downloadTranscriptsAsFile(allTranscripts, selectedFormat);
                addLogEntry(' File download initiated', 'success');
            }
            
            isDownloading = false;
            startBtn.textContent = 'Download Complete';
            
            // Clear selections after successful download
            selectedConversations.clear();
            updateDownloadButton();
            renderConversations();
        }
        
        // Download transcripts in selected format
        async function downloadTranscriptsAsFile(transcripts, format) {
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').substring(0, 19);
            
            switch (format) {
                case 'json':
                    downloadAsJson(transcripts, timestamp);
                    break;
                case 'single-txt':
                    downloadAsSingleTxt(transcripts, timestamp);
                    break;
                case 'multiple-txt':
                    await downloadAsMultipleTxt(transcripts, timestamp);
                    break;
                default:
                    downloadAsJson(transcripts, timestamp);
            }
        }
        
        // Download as JSON format
        function downloadAsJson(transcripts, timestamp) {
            const now = new Date();
            
            const jsonData = {
                exportDate: now.toISOString(),
                exportTimestamp: timestamp,
                totalConversations: transcripts.length,
                conversations: transcripts.map(t => {
                    // Parse the formatted content to extract structured data
                    const convData = allConversations.find(c => c.id === t.conversationId);
                    return {
                        conversationId: t.conversationId,
                        workitemId: t.workitemid,
                        customerName: t.customerName,
                        hasTranscript: t.hasTranscript,
                        metadata: convData ? {
                            channel: convData.channel,
                            status: convData.statuscode,
                            state: convData.statecode,
                            agent: convData.agentName,
                            queue: convData.queueName,
                            workstream: convData.workstreamName,
                            createdOn: convData.createdon,
                            modifiedOn: convData.modifiedon,
                            closedOn: convData.closedon,
                            title: convData.title
                        } : null,
                        transcriptContent: t.content,
                        rawTranscript: t.rawTranscript || null
                    };
                })
            };
            
            const fileContent = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([fileContent], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            if (transcripts.length === 1) {
                a.download = `transcript_${transcripts[0].workitemid}_${timestamp}.json`;
            } else {
                a.download = `transcripts_bulk_${transcripts.length}_${timestamp}.json`;
            }
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Download as single TXT file (original format)
        function downloadAsSingleTxt(transcripts, timestamp) {
            const now = new Date();
            let fileContent = '';
            
            if (transcripts.length === 1) {
                // Single transcript
                fileContent = transcripts[0].content;
            } else {
                // Multiple transcripts - combine them
                fileContent = ''.padEnd(79, '') + '\n';
                fileContent += '' + ' BULK TRANSCRIPT EXPORT '.padStart(52).padEnd(78) + '\n';
                fileContent += '' + ` Generated: ${now.toLocaleString()} `.padStart(52).padEnd(78) + '\n';
                fileContent += '' + ` Total Conversations: ${transcripts.length} `.padStart(52).padEnd(78) + '\n';
                fileContent += ''.padEnd(79, '') + '\n\n';
                
                // Table of contents
                fileContent += 'TABLE OF CONTENTS\n';
                fileContent += ''.repeat(80) + '\n';
                transcripts.forEach((t, i) => {
                    const status = t.hasTranscript ? '' : '';
                    fileContent += `${(i + 1).toString().padStart(3)}. ${status} ${t.workitemid} - ${t.customerName}\n`;
                });
                fileContent += '\n' + ''.repeat(80) + '\n\n';
                
                // All transcripts
                transcripts.forEach((t, i) => {
                    fileContent += `\n\n${''.repeat(40)}\n`;
                    fileContent += `TRANSCRIPT ${i + 1} OF ${transcripts.length}\n`;
                    fileContent += `${''.repeat(40)}\n\n`;
                    fileContent += t.content;
                    fileContent += '\n\n';
                });
            }
            
            // Create and download file
            const blob = new Blob([fileContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            if (transcripts.length === 1) {
                a.download = `transcript_${transcripts[0].workitemid}_${timestamp}.txt`;
            } else {
                a.download = `transcripts_bulk_${transcripts.length}_${timestamp}.txt`;
            }
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Download as multiple TXT files in a ZIP archive
        async function downloadAsMultipleTxt(transcripts, timestamp) {
            addLogEntry('Creating ZIP archive with individual files...', 'info');
            
            // Simple ZIP file creator (no external library needed)
            const files = transcripts.map(t => ({
                name: `${t.workitemid}_${t.customerName.replace(/[^a-zA-Z0-9]/g, '_')}.txt`,
                content: t.content
            }));
            
            try {
                const zipBlob = await createZipFile(files);
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `transcripts_${transcripts.length}_${timestamp}.zip`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addLogEntry(`ZIP file created with ${files.length} transcript files`, 'success');
            } catch (error) {
                addLogEntry(`Error creating ZIP: ${error.message}. Falling back to single file.`, 'error');
                // Fallback to single text file
                downloadAsSingleTxt(transcripts, timestamp);
            }
        }
        
        // Create a ZIP file from an array of {name, content} objects
        async function createZipFile(files) {
            // ZIP file format implementation
            const textEncoder = new TextEncoder();
            const localFileHeaders = [];
            const centralDirectory = [];
            let offset = 0;
            
            for (const file of files) {
                const fileName = textEncoder.encode(file.name);
                const fileContent = textEncoder.encode(file.content);
                const crc = crc32(fileContent);
                
                // Local file header
                const localHeader = new Uint8Array(30 + fileName.length);
                const localView = new DataView(localHeader.buffer);
                
                localView.setUint32(0, 0x04034b50, true); // Local file header signature
                localView.setUint16(4, 20, true); // Version needed to extract
                localView.setUint16(6, 0, true); // General purpose bit flag
                localView.setUint16(8, 0, true); // Compression method (stored)
                localView.setUint16(10, 0, true); // File last modification time
                localView.setUint16(12, 0, true); // File last modification date
                localView.setUint32(14, crc, true); // CRC-32
                localView.setUint32(18, fileContent.length, true); // Compressed size
                localView.setUint32(22, fileContent.length, true); // Uncompressed size
                localView.setUint16(26, fileName.length, true); // File name length
                localView.setUint16(28, 0, true); // Extra field length
                
                localHeader.set(fileName, 30);
                
                localFileHeaders.push({ header: localHeader, content: fileContent, offset: offset });
                
                // Central directory entry
                const centralEntry = new Uint8Array(46 + fileName.length);
                const centralView = new DataView(centralEntry.buffer);
                
                centralView.setUint32(0, 0x02014b50, true); // Central directory signature
                centralView.setUint16(4, 20, true); // Version made by
                centralView.setUint16(6, 20, true); // Version needed to extract
                centralView.setUint16(8, 0, true); // General purpose bit flag
                centralView.setUint16(10, 0, true); // Compression method
                centralView.setUint16(12, 0, true); // File last modification time
                centralView.setUint16(14, 0, true); // File last modification date
                centralView.setUint32(16, crc, true); // CRC-32
                centralView.setUint32(20, fileContent.length, true); // Compressed size
                centralView.setUint32(24, fileContent.length, true); // Uncompressed size
                centralView.setUint16(28, fileName.length, true); // File name length
                centralView.setUint16(30, 0, true); // Extra field length
                centralView.setUint16(32, 0, true); // File comment length
                centralView.setUint16(34, 0, true); // Disk number start
                centralView.setUint16(36, 0, true); // Internal file attributes
                centralView.setUint32(38, 0, true); // External file attributes
                centralView.setUint32(42, offset, true); // Relative offset of local header
                
                centralEntry.set(fileName, 46);
                centralDirectory.push(centralEntry);
                
                offset += localHeader.length + fileContent.length;
            }
            
            // End of central directory record
            const centralDirOffset = offset;
            let centralDirSize = 0;
            centralDirectory.forEach(entry => centralDirSize += entry.length);
            
            const endOfCentralDir = new Uint8Array(22);
            const endView = new DataView(endOfCentralDir.buffer);
            
            endView.setUint32(0, 0x06054b50, true); // End of central dir signature
            endView.setUint16(4, 0, true); // Number of this disk
            endView.setUint16(6, 0, true); // Disk where central directory starts
            endView.setUint16(8, files.length, true); // Number of central directory records on this disk
            endView.setUint16(10, files.length, true); // Total number of central directory records
            endView.setUint32(12, centralDirSize, true); // Size of central directory
            endView.setUint32(16, centralDirOffset, true); // Offset of start of central directory
            endView.setUint16(20, 0, true); // Comment length
            
            // Combine all parts
            const totalSize = offset + centralDirSize + 22;
            const zipData = new Uint8Array(totalSize);
            let pos = 0;
            
            for (const file of localFileHeaders) {
                zipData.set(file.header, pos);
                pos += file.header.length;
                zipData.set(file.content, pos);
                pos += file.content.length;
            }
            
            for (const entry of centralDirectory) {
                zipData.set(entry, pos);
                pos += entry.length;
            }
            
            zipData.set(endOfCentralDir, pos);
            
            return new Blob([zipData], { type: 'application/zip' });
        }
        
        // CRC-32 calculation
        function crc32(data) {
            const table = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
                let c = i;
                for (let j = 0; j < 8; j++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[i] = c;
            }
            
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i++) {
                crc = table[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }
        
        // Select all filtered conversations (for "Download All" functionality)
        function selectAllFiltered() {
            filteredConversations.forEach(conv => {
                selectedConversations.add(conv.id);
            });
            updateDownloadButton();
            renderConversations();
        }
        
        // Close selected conversations - open modal
        function closeSelectedConversations() {
            if (selectedConversations.size === 0) return;
            
            openCloseConversationsModal();
        }
        
        // Open close conversations modal
        function openCloseConversationsModal() {
            if (selectedConversations.size === 0) return;
            
            const modal = document.getElementById('closeConversationsModal');
            const title = document.getElementById('closeConversationsModalTitle');
            const subtitle = document.getElementById('closeConversationsModalSubtitle');
            const count = selectedConversations.size;
            
            title.textContent = `Close ${count} Conversation${count > 1 ? 's' : ''}`;
            subtitle.textContent = `Confirm closing ${count} conversation${count > 1 ? 's' : ''}`;
            
            // Update count
            document.getElementById('closeConvCount').textContent = count;
            
            // Reset state
            document.getElementById('closeReasonSection').style.display = 'block';
            document.getElementById('closeProgressSection').style.display = 'none';
            document.getElementById('confirmCloseBtn').disabled = false;
            
            // Populate conversation list preview
            const previewList = document.getElementById('closePreviewList');
            const selectedIds = Array.from(selectedConversations);
            const convListHTML = selectedIds.map(convId => {
                const conv = allConversations.find(c => c.id === convId);
                if (!conv) return '';
                return `
                    <div style="padding: 8px; border-bottom: 1px solid #e5e5e5; display: flex; align-items: center; gap: 12px;">
                        <span style="font-weight: 600; color: #525252; font-size: 12px;">${escapeHtml(conv.workitemid)}</span>
                        <span style="flex: 1; color: #0a0a0a; font-size: 13px;">${escapeHtml(conv.title || 'Conversation')}</span>
                        <span style="color: #737373; font-size: 12px;">${escapeHtml(conv.customerName || 'Unknown')}</span>
                    </div>
                `;
            }).join('');
            
            previewList.innerHTML = convListHTML || '<p style="text-align: center; color: #a3a3a3; padding: 20px;">No conversations selected</p>';
            
            modal.classList.add('open');
        }
        
        function closeCloseConversationsModal() {
            document.getElementById('closeConversationsModal').classList.remove('open');
        }
        
        async function confirmCloseConversations() {
            if (selectedConversations.size === 0) return;
            
            // Switch to progress view
            document.getElementById('closeReasonSection').style.display = 'none';
            document.getElementById('closeProgressSection').style.display = 'block';
            document.getElementById('confirmCloseBtn').disabled = true;
            
            const progressBar = document.getElementById('closeProgressBar');
            const progressText = document.getElementById('closeProgressText');
            const log = document.getElementById('closeLog');
            
            const selectedIds = Array.from(selectedConversations);
            const totalCount = selectedIds.length;
            let processedCount = 0;
            let successCount = 0;
            let errorCount = 0;
            
            log.innerHTML = `<div class="download-log-entry info">Starting closure of ${totalCount} conversation${totalCount > 1 ? 's' : ''}...</div>`;
            
            const xrm = getXrmContext();
            if (!xrm) {
                log.innerHTML += `<div class="download-log-entry error"> Error: Xrm context not available</div>`;
                return;
            }
            
            // Process each conversation
            for (const convId of selectedIds) {
                try {
                    // Update conversation to closed status
                    // statuscode: 2 = Closed, statecode: 1 = Inactive
                    const updateData = {
                        "statuscode": 2,
                        "statecode": 1
                    };
                    
                    await xrm.WebApi.updateRecord("msdyn_ocliveworkitem", convId, updateData);
                    
                    successCount++;
                    processedCount++;
                    const progress = (processedCount / totalCount) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Closed ${processedCount} of ${totalCount} conversations...`;
                    
                    const conv = allConversations.find(c => c.id === convId);
                    const convName = conv ? conv.title || conv.workitemid : convId.substring(0, 8);
                    log.innerHTML += `<div class="download-log-entry success"> Closed "${escapeHtml(convName)}"</div>`;
                    log.scrollTop = log.scrollHeight;
                    
                } catch (error) {
                    errorCount++;
                    processedCount++;
                    console.error('Error closing conversation:', convId, error);
                    const conv = allConversations.find(c => c.id === convId);
                    const convName = conv ? conv.title || conv.workitemid : convId.substring(0, 8);
                    log.innerHTML += `<div class="download-log-entry error"> Failed to close "${escapeHtml(convName)}": ${error.message || 'Unknown error'}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
            }
            
            // Complete
            progressBar.style.width = '100%';
            if (errorCount === 0) {
                progressText.textContent = `Successfully closed ${successCount} conversation${successCount > 1 ? 's' : ''}!`;
                log.innerHTML += `<div class="download-log-entry success" style="font-weight: 700; margin-top: 8px;"> Closure complete!</div>`;
            } else {
                progressText.textContent = `Completed with ${successCount} success, ${errorCount} error${errorCount > 1 ? 's' : ''}`;
                log.innerHTML += `<div class="download-log-entry info" style="font-weight: 700; margin-top: 8px;">Closure complete with errors</div>`;
            }
            
            // Clear selections and refresh
            setTimeout(() => {
                selectedConversations.clear();
                updateDownloadButton();
                
                // Refresh data to show updated status
                loadConversations();
                
                // Close modal after a delay
                setTimeout(() => {
                    closeCloseConversationsModal();
                }, 1500);
            }, 1000);
        }
        
        // Open assign agent modal
        let selectedAgentForAssignment = null;
        let availableAgentsForAssignment = [];
        
        function openAssignAgentModal() {
            if (selectedConversations.size === 0) return;
            
            const modal = document.getElementById('assignAgentModal');
            const title = document.getElementById('assignAgentModalTitle');
            const subtitle = document.getElementById('assignAgentModalSubtitle');
            const count = selectedConversations.size;
            
            title.textContent = `Assign ${count} Conversation${count > 1 ? 's' : ''}`;
            subtitle.textContent = `Select an available agent to assign ${count} conversation${count > 1 ? 's' : ''}`;
            
            // Reset state
            selectedAgentForAssignment = null;
            document.getElementById('confirmAssignBtn').disabled = true;
            document.getElementById('selectedAgentDisplay').classList.remove('visible');
            document.getElementById('agentModalSearchInput').value = '';
            document.getElementById('agentSelectionSection').style.display = 'block';
            document.getElementById('assignmentProgressSection').classList.remove('visible');
            
            // Load agents
            loadAvailableAgents();
            
            modal.classList.add('open');
        }
        
        function closeAssignAgentModal() {
            document.getElementById('assignAgentModal').classList.remove('open');
        }
        
        function loadAvailableAgents() {
            const container = document.getElementById('agentListContainer');
            container.innerHTML = '<div class="agent-grid-loading"><div class="spinner-ring"></div><span>Loading available agents...</span></div>';
            
            // Get agents from the existing data
            setTimeout(async () => {
                try {
                    const xrm = getXrmContext();
                    if (!xrm) {
                        console.error('Xrm context not available');
                        renderAgentList([]);
                        return;
                    }
                    
                    // Get bookable resources with user info directly
                    // This gives us the actual omnichannel agents
                    let agents = [];
                    
                    try {
                        // Get bookable resources with their linked user information
                        const bookableQuery = `?$select=_userid_value,name&$filter=_userid_value ne null and statecode eq 0&$top=200`;
                        const bookableResponse = await xrm.WebApi.retrieveMultipleRecords("bookableresource", bookableQuery);
                        console.log('Bookable resources found:', bookableResponse.entities.length);
                        
                        // Build list directly from bookable resources
                        for (const resource of bookableResponse.entities) {
                            if (resource._userid_value && resource.name) {
                                // Filter out system/bot accounts
                                const name = resource.name;
                                const isRealUser = name && 
                                    !name.includes('#') && 
                                    !name.toLowerCase().includes('integration') &&
                                    !name.toLowerCase().includes('system') &&
                                    !name.toLowerCase().includes('portal') &&
                                    !name.toLowerCase().includes('application') &&
                                    !name.toLowerCase().includes('delegated') &&
                                    !name.toLowerCase().includes('bot') &&
                                    name.trim() !== '';
                                
                                if (isRealUser) {
                                    const agentId = resource._userid_value;
                                    // Check if agent already added
                                    if (!agents.find(a => a.id.toLowerCase() === agentId.toLowerCase())) {
                                        // Try to get image from existing conversation data
                                        const conv = allConversations.find(c => c.agentId && c.agentId.toLowerCase() === agentId.toLowerCase());
                                        agents.push({
                                            id: agentId,
                                            name: name,
                                            imageUrl: conv ? conv.agentImageUrl : agentImageMap[agentId] || null
                                        });
                                        console.log('Added agent:', name, agentId);
                                    }
                                }
                            }
                        }
                    } catch (bookableError) {
                        console.log('Could not query bookable resources:', bookableError);
                    }
                    
                    // Also add agents from current conversations as a fallback
                    allConversations.forEach(conv => {
                        if (conv.agentId && conv.agentName && conv.agentName !== 'Unassigned' && conv.agentName !== 'N/A') {
                            // Check if not already in list
                            if (!agents.find(a => a.id.toLowerCase() === conv.agentId.toLowerCase())) {
                                agents.push({
                                    id: conv.agentId,
                                    name: conv.agentName,
                                    imageUrl: conv.agentImageUrl
                                });
                                console.log('Added agent from conversation:', conv.agentName, conv.agentId);
                            }
                        }
                    });
                    
                    // Sort by name
                    availableAgentsForAssignment = agents.sort((a, b) => a.name.localeCompare(b.name));
                    
                    console.log('Available agents for assignment:', availableAgentsForAssignment.length, availableAgentsForAssignment);
                    
                    renderAgentList(availableAgentsForAssignment);
                } catch (error) {
                    console.error('Error loading agents:', error);
                    renderAgentList([]);
                }
            }, 300);
        }
        
        function renderAgentList(agents) {
            const container = document.getElementById('agentListContainer');
            
            if (agents.length === 0) {
                container.innerHTML = `
                    <div class="agent-grid-empty">
                        <div class="empty-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M16 21v-2a4 4 0 00-4-4H5a4 4 0 00-4 4v2"></path>
                                <circle cx="8.5" cy="7" r="4"></circle>
                                <line x1="23" y1="11" x2="17" y2="11"></line>
                            </svg>
                        </div>
                        <div class="empty-title">No agents available</div>
                        <div class="empty-desc">No omnichannel agents were found</div>
                    </div>
                `;
                return;
            }
            
            const agentListHTML = agents.map(agent => {
                const initials = agent.name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                const avatarBg = getColorForString(agent.name);
                const avatarContent = agent.imageUrl 
                    ? `<img src="${agent.imageUrl}" alt="${escapeHtml(agent.name)}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                       <div class="initials" style="display: none; background: ${avatarBg};">${initials}</div>`
                    : `<div class="initials" style="background: ${avatarBg};">${initials}</div>`;
                
                return `
                    <div class="agent-card" data-agent-id="${agent.id}" data-agent-name="${escapeHtml(agent.name)}" onclick="selectAgent('${agent.id}', '${escapeHtml(agent.name).replace(/'/g, "\\'")}')">
                        <div class="agent-card-avatar">${avatarContent}</div>
                        <div class="agent-card-info">
                            <div class="agent-card-name">${escapeHtml(agent.name)}</div>
                            <div class="agent-card-status">
                                <span class="status-dot"></span>
                                Available
                            </div>
                        </div>
                        <div class="agent-card-check">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = agentListHTML;
        }
        
        function selectAgent(agentId, agentName) {
            selectedAgentForAssignment = { id: agentId, name: agentName };
            
            // Update UI - use agent-card class
            document.querySelectorAll('.agent-card').forEach(item => {
                item.classList.remove('selected');
            });
            
            const selectedItem = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }
            
            // Show selected agent banner
            const agent = availableAgentsForAssignment.find(a => a.id === agentId);
            if (agent) {
                const initials = agent.name.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase();
                const avatarBg = getColorForString(agent.name);
                const avatarContent = agent.imageUrl 
                    ? `<img src="${agent.imageUrl}" alt="${escapeHtml(agent.name)}">`
                    : `<div class="initials" style="background: ${avatarBg};">${initials}</div>`;
                
                document.getElementById('selectedAgentInfo').innerHTML = `
                    <div class="agent-card-avatar">${avatarContent}</div>
                    <div class="agent-card-info">
                        <div class="agent-card-name">${escapeHtml(agent.name)}</div>
                    </div>
                `;
                document.getElementById('selectedAgentDisplay').classList.add('visible');
            }
            
            // Enable confirm button
            document.getElementById('confirmAssignBtn').disabled = false;
        }
        
        function filterAgentsInModal() {
            const searchTerm = document.getElementById('agentModalSearchInput').value.toLowerCase().trim();
            
            if (!searchTerm) {
                renderAgentList(availableAgentsForAssignment);
                return;
            }
            
            const filtered = availableAgentsForAssignment.filter(agent => 
                agent.name.toLowerCase().includes(searchTerm)
            );
            
            renderAgentList(filtered);
        }
        
        async function confirmAgentAssignment() {
            console.log('confirmAgentAssignment called');
            console.log('selectedAgentForAssignment:', selectedAgentForAssignment);
            console.log('selectedConversations.size:', selectedConversations.size);
            
            if (!selectedAgentForAssignment || selectedConversations.size === 0) {
                console.log('Early return - no agent selected or no conversations');
                return;
            }
            
            // Switch to progress view
            document.getElementById('agentSelectionSection').style.display = 'none';
            document.getElementById('assignmentProgressSection').classList.add('visible');
            document.getElementById('confirmAssignBtn').disabled = true;
            
            const progressBar = document.getElementById('assignmentProgressBar');
            const progressText = document.getElementById('assignmentProgressText');
            const log = document.getElementById('assignmentLog');
            
            const selectedIds = Array.from(selectedConversations);
            const totalCount = selectedIds.length;
            let processedCount = 0;
            let successCount = 0;
            let errorCount = 0;
            
            log.innerHTML = `<div class="assign-log-entry info">Starting assignment of ${totalCount} conversation${totalCount > 1 ? 's' : ''} to ${escapeHtml(selectedAgentForAssignment.name)}...</div>`;
            
            const xrm = getXrmContext();
            if (!xrm) {
                log.innerHTML += `<div class="assign-log-entry error"> Error: Xrm context not available</div>`;
                console.error('Xrm context not available');
                return;
            }
            
            const clientUrl = xrm.Utility.getGlobalContext().getClientUrl();
            console.log('Processing', totalCount, 'conversations for agent:', selectedAgentForAssignment.name, selectedAgentForAssignment.id);
            
            // Process each conversation
            for (const convId of selectedIds) {
                try {
                    // First, check if the conversation is open (live) or closed
                    const conv = allConversations.find(c => c.id === convId);
                    const isLive = conv && conv.statecode === 0; // statecode 0 = Open
                    const convName = conv ? conv.title : convId.substring(0, 8);
                    
                    console.log('Processing conversation:', convId, 'isLive:', isLive);
                    
                    let success = false;
                    let lastError = null;
                    
                    if (isLive) {
                        // For LIVE conversations, try CCaaS transfer API
                        console.log('Attempting CCaaS transfer for live conversation...');
                        log.innerHTML += `<div class="assign-log-entry info"> Transferring live conversation "${escapeHtml(convName)}"...</div>`;
                        log.scrollTop = log.scrollHeight;
                        
                        try {
                            // Try CCaaS_InitiateAgentGroupTransfer
                            const transferResp = await fetch(`${clientUrl}/api/data/v9.2/CCaaS_InitiateAgentGroupTransfer`, {
                                method: 'POST',
                                headers: {
                                    'OData-MaxVersion': '4.0',
                                    'OData-Version': '4.0',
                                    'Accept': 'application/json',
                                    'Content-Type': 'application/json; charset=utf-8'
                                },
                                body: JSON.stringify({
                                    "LiveWorkItemId": convId,
                                    "TargetAgentId": selectedAgentForAssignment.id
                                })
                            });
                            
                            if (transferResp.ok || transferResp.status === 204) {
                                success = true;
                                console.log('CCaaS transfer succeeded');
                            } else {
                                const errData = await transferResp.json().catch(() => ({}));
                                lastError = errData.error?.message || `HTTP ${transferResp.status}`;
                                console.log('CCaaS transfer failed:', lastError);
                            }
                        } catch (e) {
                            lastError = e.message;
                            console.log('CCaaS transfer exception:', e.message);
                        }
                        
                        // Fallback: try owner update for live conversation
                        if (!success) {
                            console.log('Falling back to owner update for live conversation...');
                            try {
                                await xrm.WebApi.updateRecord("msdyn_ocliveworkitem", convId, {
                                    "ownerid@odata.bind": `/systemusers(${selectedAgentForAssignment.id})`
                                });
                                success = true;
                                console.log('Owner update succeeded for live conversation');
                            } catch (e) {
                                lastError = e.message;
                                console.log('Owner update failed:', e.message);
                            }
                        }
                    } else {
                        // For CLOSED conversations, just update owner (for reporting/assignment purposes)
                        console.log('Updating owner for closed conversation...');
                        try {
                            await xrm.WebApi.updateRecord("msdyn_ocliveworkitem", convId, {
                                "ownerid@odata.bind": `/systemusers(${selectedAgentForAssignment.id})`
                            });
                            success = true;
                            console.log('Owner update succeeded for closed conversation');
                        } catch (e) {
                            lastError = e.message;
                            console.log('Owner update failed:', e.message);
                        }
                    }
                    
                    if (success) {
                        successCount++;
                        const statusNote = isLive ? ' (transferred)' : ' (owner updated)';
                        log.innerHTML += `<div class="assign-log-entry success"> Assigned "${escapeHtml(convName)}" to ${escapeHtml(selectedAgentForAssignment.name)}${statusNote}</div>`;
                    } else {
                        throw new Error(lastError || 'Assignment failed');
                    }
                    
                    processedCount++;
                    const progress = (processedCount / totalCount) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Processing ${processedCount} of ${totalCount} conversations...`;
                    log.scrollTop = log.scrollHeight;
                    
                } catch (error) {
                    errorCount++;
                    processedCount++;
                    console.error('Error assigning conversation:', convId, error);
                    const conv = allConversations.find(c => c.id === convId);
                    const convName = conv ? conv.title : convId.substring(0, 8);
                    log.innerHTML += `<div class="assign-log-entry error"> Failed to assign "${escapeHtml(convName)}": ${error.message || 'Unknown error'}</div>`;
                    log.scrollTop = log.scrollHeight;
                }
            }
            
            // Complete
            progressBar.style.width = '100%';
            if (errorCount === 0) {
                progressText.textContent = `Successfully assigned ${successCount} conversation${successCount > 1 ? 's' : ''}!`;
                log.innerHTML += `<div class="assign-log-entry success" style="font-weight: 700; margin-top: 8px;"> Assignment complete!</div>`;
            } else {
                progressText.textContent = `Completed with ${successCount} success, ${errorCount} error${errorCount > 1 ? 's' : ''}`;
                log.innerHTML += `<div class="assign-log-entry info" style="font-weight: 700; margin-top: 8px;">Assignment complete with errors</div>`;
            }
            
            // Clear selections and refresh
            setTimeout(() => {
                selectedConversations.clear();
                updateDownloadButton();
                
                // Refresh data to show updated assignments
                loadConversations();
                
                // Close modal after a delay
                setTimeout(() => {
                    closeAssignAgentModal();
                }, 1500);
            }, 1000);
        }
        
        // Clear all selections
        function clearAllSelections() {
            selectedConversations.clear();
            updateDownloadButton();
            renderConversations();
        }

        // Initialize on load
        window.addEventListener('load', initialize);
        
        // Set up click-outside handlers for dropdowns
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date inputs to reasonable values
            const today = new Date();
            const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
            
            document.getElementById('customEndDate').value = today.toISOString().split('T')[0];
            document.getElementById('customStartDate').max = today.toISOString().split('T')[0];
            document.getElementById('customEndDate').max = today.toISOString().split('T')[0];
            
            // Global click handler to close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside date picker
                const datePicker = document.querySelector('.date-picker-group');
                if (datePicker && !datePicker.contains(e.target)) {
                    closeDatePicker();
                }
                
                // Check if click is outside channel dropdown
                const channelDropdown = document.getElementById('channelDropdown');
                if (channelDropdown && !channelDropdown.contains(e.target)) {
                    const channelMenu = document.getElementById('channelDropdownMenu');
                    const channelTrigger = channelDropdown.querySelector('.searchable-trigger');
                    if (channelMenu) channelMenu.classList.remove('open');
                    if (channelTrigger) channelTrigger.classList.remove('open');
                }
                
                // Check if click is outside queue dropdown
                const queueDropdown = document.getElementById('queueDropdown');
                if (queueDropdown && !queueDropdown.contains(e.target)) {
                    const queueMenu = document.getElementById('queueDropdownMenu');
                    const queueTrigger = queueDropdown.querySelector('.searchable-trigger');
                    if (queueMenu) queueMenu.classList.remove('open');
                    if (queueTrigger) queueTrigger.classList.remove('open');
                }
                
                // Check if click is outside agent dropdown
                const agentDropdown = document.getElementById('agentDropdown');
                if (agentDropdown && !agentDropdown.contains(e.target)) {
                    const agentMenu = document.getElementById('agentDropdownMenu');
                    const agentTrigger = agentDropdown.querySelector('.searchable-trigger');
                    if (agentMenu) agentMenu.classList.remove('open');
                    if (agentTrigger) agentTrigger.classList.remove('open');
                }
            });
        });

        // Make functions globally accessible for inline onclick handlers
        window.toggleDatePicker = toggleDatePicker;
        window.toggleSearchableDropdown = toggleSearchableDropdown;
        window.selectDropdownOption = selectDropdownOption;
        window.filterDropdownOptions = filterDropdownOptions;
        window.toggleMultiSelectOption = toggleMultiSelectOption;
        window.clearMultiSelect = clearMultiSelect;
        window.applyMultiSelect = applyMultiSelect;
        window.selectPreset = selectPreset;
        window.applyCustomRange = applyCustomRange;
        window.updateCustomRange = updateCustomRange;
        window.loadConversations = loadConversations;
        window.applyFilters = applyFilters;
        window.setStatusFilter = setStatusFilter;
        window.filterByStatus = filterByStatus;
        window.sortBy = sortBy;
        window.debounceSearch = debounceSearch;
        window.previousPage = previousPage;
        window.nextPage = nextPage;
        // Transcript download functions
        window.toggleConversationSelection = toggleConversationSelection;
        window.toggleSelectAll = toggleSelectAll;
        window.openDownloadModal = openDownloadModal;
        window.closeDownloadModal = closeDownloadModal;
        window.startTranscriptDownload = startTranscriptDownload;
        window.debugTranscriptData = debugTranscriptData;
        window.selectAllFiltered = selectAllFiltered;
        window.clearAllSelections = clearAllSelections;
        window.closeSelectedConversations = closeSelectedConversations;
        window.openCloseConversationsModal = openCloseConversationsModal;
        window.closeCloseConversationsModal = closeCloseConversationsModal;
        window.confirmCloseConversations = confirmCloseConversations;
        window.openAssignAgentModal = openAssignAgentModal;
        window.closeAssignAgentModal = closeAssignAgentModal;
        window.selectAgent = selectAgent;
        window.filterAgentsInModal = filterAgentsInModal;
        window.confirmAgentAssignment = confirmAgentAssignment;
        // Column selector functions
        window.filterColumnSelector = filterColumnSelector;
    </script>
</body>
</html>
